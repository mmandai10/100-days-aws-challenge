# Daily Progress Log - 2026年2月

> Phase 2: コンテナ基礎（Docker, ECS）

---

## Day 45 (2026-02-01)

**テーマ:** Docker 入門 + Git ブランチ戦略

**完了したこと:**

1. **Git ブランチ戦略の理解**
   - GitHub Flow を採用（シンプルで小〜中規模向け）
   - feature ブランチ → PR → merge の流れ
   - 依存関係がある場合の対処パターン 4 つ
   - コミットメッセージ規約（Conventional Commits）
   - 設計力 = 分割力（並行開発できる粒度に分ける）

2. **Docker 基本概念**
   - イメージ: テンプレート（型）、変更不可
   - コンテナ: イメージから作った実体
   - レジストリ: イメージの保存場所（Docker Hub, ECR）
   - 揮発性: コンテナ削除で変更は消える → Dockerfile で解決

3. **Docker 基本コマンド実践**
   - `docker run hello-world` で動作確認
   - `docker run -d -p 8080:80 --name my-nginx nginx` で Web サーバー起動
   - `docker exec -it my-nginx bash` でコンテナ内に入る
   - コンテナ内の index.html を編集 → ブラウザで確認
   - コンテナ削除 → 再作成 → 変更が消えることを確認

4. **学んだコマンド**
   - `docker run`: コンテナ作成・起動
   - `docker ps` / `docker ps -a`: コンテナ一覧
   - `docker images`: イメージ一覧
   - `docker logs`: ログ表示
   - `docker exec -it`: コンテナ内でコマンド実行
   - `docker stop` / `docker rm`: 停止・削除
   - `docker container prune`: 停止済み一括削除

**環境:**
- Docker Desktop: 29.0.1
- Docker Compose: v2.40.3

**重要な学び:**
- Windows 上で Linux コンテナが動く（Debian GNU/Linux 13）
- コンテナ内の変更は揮発性 → Dockerfile でイメージに含める
- Git ブランチ戦略は「開発者の腕」、設計段階で依存関係を整理

**次回 Day 46:** Dockerfile 作成、マルチステージビルド

---

## Day 46 (2026-02-01)

**テーマ:** Dockerfile 基礎

**完了したこと:**

1. **Dockerfile の基本**
   - Dockerfile = イメージの設計図
   - 揮発性問題を解決（手動変更 → Dockerfile で永続化）
   - nginx:alpine ベースでカスタムイメージ作成

2. **主要命令**
   - `FROM`: ベースイメージ指定
   - `WORKDIR`: 作業ディレクトリ設定
   - `COPY`: ファイルをコンテナにコピー
   - `RUN`: ビルド時にコマンド実行
   - `CMD`: コンテナ起動時のコマンド
   - `ENV`: 環境変数設定
   - `EXPOSE`: ポート宣言（ドキュメント用）

3. **Node.js アプリのコンテナ化**
   - node:20-alpine ベースで API サーバー作成
   - package.json → npm install → server.js の順序

4. **レイヤーキャッシュ**
   - Docker は各命令をレイヤーとして保存
   - 変更がなければ CACHED で再利用（高速化）
   - package.json と server.js を分けてコピーする理由

5. **マルチステージビルド（概念）**
   - ビルド用ステージと実行用ステージを分離
   - 最終イメージに不要なファイル（node_modules）を含めない
   - 487MB → 45MB のようなサイズ削減が可能
   - 検証/本番環境（デプロイ先）とは別の概念

**作成したファイル:**
- `projects/container-basics/day46-dockerfile/Dockerfile`（nginx 用）
- `projects/container-basics/day46-dockerfile/index.html`
- `projects/container-basics/day46-dockerfile/node-app/Dockerfile`
- `projects/container-basics/day46-dockerfile/node-app/server.js`
- `projects/container-basics/day46-dockerfile/node-app/package.json`

**学んだコマンド:**
- `docker build -t イメージ名:タグ .`: イメージをビルド
- `COPY --from=builder`: マルチステージで前ステージからコピー

**次回 Day 47:** Docker Compose（マルチコンテナ）

---

## Day 47 (2026-02-01)

**テーマ:** Docker Compose + セキュリティ事件の学習

**完了したこと:**

1. **セキュリティ事件の理解**
   - サントリー事件（2026年1月）: 委託先へのランサムウェア攻撃、914人の個人情報流出
   - アスクル事件（2025年10月）: 74万件の個人情報流出、売上95%減
   - サプライチェーン攻撃: 委託先の弱い部分を突いて本体に侵入
   - ランサムウェア: ファイルを暗号化して身代金を要求
   - 4ヶ月の潜伏期間: 偵察、認証情報収集、セキュリティソフト無効化

2. **Docker Compose 基礎**
   - 複数コンテナを 1 つの YAML ファイルで管理
   - `services:` 配下にコンテナを定義
   - サービス名が DNS 名になる（コンテナ間通信）
   - `depends_on` で起動順序を制御
   - `networks` でコンテナ間ネットワークを構成

3. **実践: 2 コンテナ構成**
   - frontend（nginx）: ポート 8080 で公開
   - backend（Node.js API）: ポート 3000
   - フロントエンドからバックエンド API を呼び出し
   - 商品一覧、ヘルスチェック、サーバー情報 API

4. **Docker Compose コマンド**
   - `docker compose up --build`: ビルドして起動
   - `docker compose down`: 停止して削除
   - `docker compose ps`: 稼働中コンテナ一覧
   - `docker compose logs -f`: リアルタイムログ

**作成したファイル:**
- `projects/container-basics/day47-compose/docker-compose.yml`
- `projects/container-basics/day47-compose/frontend/Dockerfile`
- `projects/container-basics/day47-compose/frontend/index.html`
- `projects/container-basics/day47-compose/backend/Dockerfile`
- `projects/container-basics/day47-compose/backend/package.json`
- `projects/container-basics/day47-compose/backend/server.js`

**セキュリティの学び:**
- 多要素認証（MFA）は必須
- サプライチェーン（委託先）のセキュリティも重要
- 監視の死角を作らない
- バックアップは別の場所に保管

**次回 Day 48:** Docker Compose 応用（ボリューム、環境変数ファイル）

---

## Day 48 (2026-02-01)

**テーマ:** ボリューム + 環境変数 + Docker の本質理解

**完了したこと:**

1. **Day 47 復習：サービス名 DNS 解決の実証**
   - コンテナは IP アドレスを持つ（実測: 172.18.0.3 など）
   - Docker 内蔵 DNS サーバー: 127.0.0.11
   - `nslookup frontend` → 172.18.0.3 を返す
   - `ping frontend` → 名前解決して通信成功
   - DNS はサービス名 → IP アドレス変換を行う

2. **Docker Engine の構成要素**
   - Container Runtime: コンテナ起動/停止/削除
   - Image Manager: イメージの pull/build/push
   - Network Manager: DNS + IP 割り当て + ルーティング
   - Volume Manager: データ永続化
   - API Server: CLI からの命令受付
   - Logging Driver: docker logs の出力先

3. **Docker の本質（3つの目標）**
   - 環境差異の最小化:「俺の環境では動く」問題を解消
   - ポータビリティ: コンテナ部分のみ移行可能（AWS マネージドサービスは対象外）
   - 分離と軽量化: マイクロサービス構成で有効（モノリスなら VM でも可）

4. **ボリューム実験（揮発性 vs 永続化）**
   - ボリュームなし: コンテナ削除でデータ消失（実証済み）
   - ボリュームあり: コンテナ削除後もデータ残存（実証済み）

5. **ボリュームの実体（Windows）**
   - 場所: `C:\Users\mitsu\AppData\Local\Docker\wsl\disk\docker_data.vhdx`
   - サイズ: 7.71 GB（実測）
   - ローカル PC のディスク上に存在（メモリではない）

6. **Docker Volume を本番 DB に使わない理由**
   - 単一障害点（サーバー故障 = データ消失）
   - 自動バックアップなし
   - ポイントインタイムリカバリ不可
   - 複数サーバーからアクセス不可
   - → 本番は RDS などマネージドサービスを使用

7. **Docker Compose でボリューム管理**
   - `volumes:` セクションで Named Volume を定義
   - `db-data:/var/lib/postgresql/data` でマウント
   - PostgreSQL + Node.js API の 2 コンテナ構成で実践

8. **環境変数の外部化**
   - .env ファイルで機密情報を管理
   - docker-compose.yml では `${VARIABLE}` で参照
   - .gitignore に .env を追加（Git にコミットしない）

9. **AWS での対応関係**
   - .env → Secrets Manager / Parameter Store
   - Secrets Manager: 自動ローテーション、RDS 連携
   - Parameter Store: 無料、軽い機密情報向け

**作成したファイル:**
- `projects/container-basics/day48-volumes/docker-compose.yml`
- `projects/container-basics/day48-volumes/.env`
- `projects/container-basics/day48-volumes/.gitignore`
- `projects/container-basics/day48-volumes/app/Dockerfile`
- `projects/container-basics/day48-volumes/app/package.json`
- `projects/container-basics/day48-volumes/app/server.js`

**学んだコマンド:**
- `docker volume create`: ボリューム作成
- `docker volume ls`: ボリューム一覧
- `docker volume inspect`: ボリューム詳細
- `docker network inspect`: ネットワーク詳細（IP アドレス確認）
- `docker exec コンテナ名 cat /etc/resolv.conf`: DNS 設定確認
- `docker exec コンテナ名 nslookup サービス名`: 名前解決確認

**重要な学び:**
- Docker Volume は「永続化」は可能だが「可用性・耐障害性・運用性」が不足
- 開発環境: Docker Volume で十分
- 本番環境: RDS, EFS, S3 などマネージドサービスを使用
- ポータビリティはコンテナ部分のみ（AWS 専用サービスは移行対象外）

**次回 Day 49:** Docker Compose 応用（ヘルスチェック、リソース制限）

---

## Day 49 (2026-02-01)

**テーマ:** Docker Compose 応用（ヘルスチェック、リソース制限）

**完了したこと:**

1. **depends_on だけでは不十分な問題を体験**
   - Day 48 のコードで backend が DB 接続エラーでクラッシュ
   - 原因: depends_on は「コンテナ起動」を待つだけ
   - PostgreSQL が「接続可能」になるまで待たない

2. **ヘルスチェックの実装**
   - `healthcheck` セクションで DB の接続可能状態を監視
   - `pg_isready` コマンドで PostgreSQL の状態を確認
   - `depends_on: condition: service_healthy` で healthy まで待機

3. **ヘルスチェック設定項目**
   - `test`: チェックコマンド（pg_isready）
   - `interval`: チェック間隔（5秒）
   - `timeout`: タイムアウト（5秒）
   - `retries`: 失敗許容回数（5回）
   - `start_period`: 猶予期間（10秒）

4. **リソース制限の実装**
   - `deploy.resources.limits`: 上限（超えると制限/OOM Kill）
   - `deploy.resources.reservations`: 予約（最低保証）
   - CPU: 0.5（50%）、メモリ: 256MB で設定

5. **ノイジーネイバー問題の理解**
   - 1つのコンテナの暴走が他を巻き込む問題
   - リソース制限で「使える量の上限」を決めて防止
   - ただし全体設計（キャパシティプランニング）は別の話
   - ECS Fargate はタスクごとに専用リソース確保で問題回避

6. **実測結果**
   - db: `Up 28 seconds (healthy)` ← ヘルスチェック成功
   - backend: `Up 22 seconds` ← db healthy 後に起動（6秒待機）
   - `docker stats`: MEM USAGE / LIMIT = 23.49MiB / 256MiB

**作成したファイル:**
- `projects/container-basics/day49-healthcheck/docker-compose.yml`
- `projects/container-basics/day49-healthcheck/.env`
- `projects/container-basics/day49-healthcheck/.gitignore`
- `projects/container-basics/day49-healthcheck/app/Dockerfile`
- `projects/container-basics/day49-healthcheck/app/package.json`
- `projects/container-basics/day49-healthcheck/app/server.js`

**学んだコマンド:**
- `docker stats --no-stream`: リソース使用状況を一度だけ表示

**ECS/Kubernetes との対応:**
| Docker Compose | ECS | Kubernetes |
|----------------|-----|------------|
| `limits.memory` | Task Definition `memory` | `resources.limits.memory` |
| `limits.cpus` | Task Definition `cpu` | `resources.limits.cpu` |
| `reservations` | Soft Limit | `resources.requests` |

**次回 Day 50:** 12-Factor App、コンテナ設計ベストプラクティス

---

## Day 50 (2026-02-02)

**テーマ:** 12-Factor App、コンテナ設計ベストプラクティス

**完了したこと:**

1. **12-Factor App 概要**
   - 2011年 Heroku 創業者が発表した SaaS 設計原則
   - クラウドネイティブ、コンテナ、マイクロサービスの基盤
   - 12原則のうち、コンテナで特に重要な4つに絞って学習

2. **原則3: Config（設定は環境変数で）**
   - イメージに機密情報を焼き込まない
   - 実行時に環境変数で注入
   - Day 48 で実践済み（.env + docker-compose.yml）

3. **原則6: Processes（ステートレス）**
   - 状態はコンテナ内に持たない
   - セッション → Redis/DynamoDB
   - ファイル → S3/EFS
   - DB → RDS
   - スケール・障害復旧・デプロイが容易になる

4. **原則9: Disposability（即座に起動・停止）**
   - SIGTERM で graceful shutdown
   - Day 49 のヘルスチェックと関連

5. **原則11: Logs（stdout/stderr へ出力）**
   - ファイルに書かない（コンテナは揮発性）
   - console.log → docker logs → CloudWatch Logs

6. **CMD の書き方と PID 1 問題**
   - exec form: `CMD ["node", "server.js"]` → node が PID 1
   - shell form: `CMD node server.js` → sh が PID 1、node は子プロセス
   - docker stop は PID 1 に SIGTERM を送る
   - shell form だと sh が SIGTERM を子プロセスに転送しない
   - → node は SIGTERM を受け取れず、SIGKILL で強制終了
   - **結論: 常に exec form（配列形式）を使う**

7. **SIGTERM vs SIGKILL**
   - SIGTERM: 終了のお願い、プロセス側で処理可能（後片付けできる）
   - SIGKILL: 強制終了、プロセス側で処理不可能（即死）
   - docker stop: SIGTERM → 10秒待機 → SIGKILL

8. **Graceful Shutdown 実装パターン**
   ```javascript
   process.on('SIGTERM', () => {
     server.close(() => process.exit(0));
   });
   ```

**コンテナ設計チェックリスト:**
- [ ] 設定は環境変数で注入
- [ ] イメージに機密情報を焼き込まない
- [ ] ログは stdout/stderr
- [ ] CMD は exec form（配列形式）
- [ ] SIGTERM で graceful shutdown
- [ ] ヘルスチェック実装
- [ ] 状態は外部（RDS, S3, Redis）に保存

**Forbes 記事との関連:**
- 「従業員ゼロで1.5億円ビジネス」→ システムでレバレッジ
- 12-Factor App = スケールするシステムの設計原則
- 200日チャレンジで学ぶスキル = 一人で大きな価値を生む基盤

**次回 Day 51:** ECR（Elastic Container Registry）入門

---

<!-- 以下、Day 51〜 を追記していく -->
