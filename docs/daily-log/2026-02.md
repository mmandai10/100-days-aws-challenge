# Daily Progress Log - 2026年2月

> Phase 2: コンテナ基礎（Docker, ECS）

---

## Day 45 (2026-02-01)

**テーマ:** Docker 入門 + Git ブランチ戦略

**完了したこと:**

1. **Git ブランチ戦略の理解**
   - GitHub Flow を採用（シンプルで小〜中規模向け）
   - feature ブランチ → PR → merge の流れ
   - 依存関係がある場合の対処パターン 4 つ
   - コミットメッセージ規約（Conventional Commits）
   - 設計力 = 分割力（並行開発できる粒度に分ける）

2. **Docker 基本概念**
   - イメージ: テンプレート（型）、変更不可
   - コンテナ: イメージから作った実体
   - レジストリ: イメージの保存場所（Docker Hub, ECR）
   - 揮発性: コンテナ削除で変更は消える → Dockerfile で解決

3. **Docker 基本コマンド実践**
   - `docker run hello-world` で動作確認
   - `docker run -d -p 8080:80 --name my-nginx nginx` で Web サーバー起動
   - `docker exec -it my-nginx bash` でコンテナ内に入る
   - コンテナ内の index.html を編集 → ブラウザで確認
   - コンテナ削除 → 再作成 → 変更が消えることを確認

4. **学んだコマンド**
   - `docker run`: コンテナ作成・起動
   - `docker ps` / `docker ps -a`: コンテナ一覧
   - `docker images`: イメージ一覧
   - `docker logs`: ログ表示
   - `docker exec -it`: コンテナ内でコマンド実行
   - `docker stop` / `docker rm`: 停止・削除
   - `docker container prune`: 停止済み一括削除

**環境:**
- Docker Desktop: 29.0.1
- Docker Compose: v2.40.3

**重要な学び:**
- Windows 上で Linux コンテナが動く（Debian GNU/Linux 13）
- コンテナ内の変更は揮発性 → Dockerfile でイメージに含める
- Git ブランチ戦略は「開発者の腕」、設計段階で依存関係を整理

**次回 Day 46:** Dockerfile 作成、マルチステージビルド

---

## Day 46 (2026-02-01)

**テーマ:** Dockerfile 基礎

**完了したこと:**

1. **Dockerfile の基本**
   - Dockerfile = イメージの設計図
   - 揮発性問題を解決（手動変更 → Dockerfile で永続化）
   - nginx:alpine ベースでカスタムイメージ作成

2. **主要命令**
   - `FROM`: ベースイメージ指定
   - `WORKDIR`: 作業ディレクトリ設定
   - `COPY`: ファイルをコンテナにコピー
   - `RUN`: ビルド時にコマンド実行
   - `CMD`: コンテナ起動時のコマンド
   - `ENV`: 環境変数設定
   - `EXPOSE`: ポート宣言（ドキュメント用）

3. **Node.js アプリのコンテナ化**
   - node:20-alpine ベースで API サーバー作成
   - package.json → npm install → server.js の順序

4. **レイヤーキャッシュ**
   - Docker は各命令をレイヤーとして保存
   - 変更がなければ CACHED で再利用（高速化）
   - package.json と server.js を分けてコピーする理由

5. **マルチステージビルド（概念）**
   - ビルド用ステージと実行用ステージを分離
   - 最終イメージに不要なファイル（node_modules）を含めない
   - 487MB → 45MB のようなサイズ削減が可能
   - 検証/本番環境（デプロイ先）とは別の概念

**作成したファイル:**
- `projects/container-basics/day46-dockerfile/Dockerfile`（nginx 用）
- `projects/container-basics/day46-dockerfile/index.html`
- `projects/container-basics/day46-dockerfile/node-app/Dockerfile`
- `projects/container-basics/day46-dockerfile/node-app/server.js`
- `projects/container-basics/day46-dockerfile/node-app/package.json`

**学んだコマンド:**
- `docker build -t イメージ名:タグ .`: イメージをビルド
- `COPY --from=builder`: マルチステージで前ステージからコピー

**次回 Day 47:** Docker Compose（マルチコンテナ）

---

## Day 47 (2026-02-01)

**テーマ:** Docker Compose + セキュリティ事件の学習

**完了したこと:**

1. **セキュリティ事件の理解**
   - サントリー事件（2026年1月）: 委託先へのランサムウェア攻撃、914人の個人情報流出
   - アスクル事件（2025年10月）: 74万件の個人情報流出、売上95%減
   - サプライチェーン攻撃: 委託先の弱い部分を突いて本体に侵入
   - ランサムウェア: ファイルを暗号化して身代金を要求
   - 4ヶ月の潜伏期間: 偵察、認証情報収集、セキュリティソフト無効化

2. **Docker Compose 基礎**
   - 複数コンテナを 1 つの YAML ファイルで管理
   - `services:` 配下にコンテナを定義
   - サービス名が DNS 名になる（コンテナ間通信）
   - `depends_on` で起動順序を制御
   - `networks` でコンテナ間ネットワークを構成

3. **実践: 2 コンテナ構成**
   - frontend（nginx）: ポート 8080 で公開
   - backend（Node.js API）: ポート 3000
   - フロントエンドからバックエンド API を呼び出し
   - 商品一覧、ヘルスチェック、サーバー情報 API

4. **Docker Compose コマンド**
   - `docker compose up --build`: ビルドして起動
   - `docker compose down`: 停止して削除
   - `docker compose ps`: 稼働中コンテナ一覧
   - `docker compose logs -f`: リアルタイムログ

**作成したファイル:**
- `projects/container-basics/day47-compose/docker-compose.yml`
- `projects/container-basics/day47-compose/frontend/Dockerfile`
- `projects/container-basics/day47-compose/frontend/index.html`
- `projects/container-basics/day47-compose/backend/Dockerfile`
- `projects/container-basics/day47-compose/backend/package.json`
- `projects/container-basics/day47-compose/backend/server.js`

**セキュリティの学び:**
- 多要素認証（MFA）は必須
- サプライチェーン（委託先）のセキュリティも重要
- 監視の死角を作らない
- バックアップは別の場所に保管

**次回 Day 48:** Docker Compose 応用（ボリューム、環境変数ファイル）

---

## Day 48 (2026-02-01)

**テーマ:** ボリューム + 環境変数 + Docker の本質理解

**完了したこと:**

1. **Day 47 復習：サービス名 DNS 解決の実証**
   - コンテナは IP アドレスを持つ（実測: 172.18.0.3 など）
   - Docker 内蔵 DNS サーバー: 127.0.0.11
   - `nslookup frontend` → 172.18.0.3 を返す
   - `ping frontend` → 名前解決して通信成功
   - DNS はサービス名 → IP アドレス変換を行う

2. **Docker Engine の構成要素**
   - Container Runtime: コンテナ起動/停止/削除
   - Image Manager: イメージの pull/build/push
   - Network Manager: DNS + IP 割り当て + ルーティング
   - Volume Manager: データ永続化
   - API Server: CLI からの命令受付
   - Logging Driver: docker logs の出力先

3. **Docker の本質（3つの目標）**
   - 環境差異の最小化:「俺の環境では動く」問題を解消
   - ポータビリティ: コンテナ部分のみ移行可能（AWS マネージドサービスは対象外）
   - 分離と軽量化: マイクロサービス構成で有効（モノリスなら VM でも可）

4. **ボリューム実験（揮発性 vs 永続化）**
   - ボリュームなし: コンテナ削除でデータ消失（実証済み）
   - ボリュームあり: コンテナ削除後もデータ残存（実証済み）

5. **ボリュームの実体（Windows）**
   - 場所: `C:\Users\mitsu\AppData\Local\Docker\wsl\disk\docker_data.vhdx`
   - サイズ: 7.71 GB（実測）
   - ローカル PC のディスク上に存在（メモリではない）

6. **Docker Volume を本番 DB に使わない理由**
   - 単一障害点（サーバー故障 = データ消失）
   - 自動バックアップなし
   - ポイントインタイムリカバリ不可
   - 複数サーバーからアクセス不可
   - → 本番は RDS などマネージドサービスを使用

7. **Docker Compose でボリューム管理**
   - `volumes:` セクションで Named Volume を定義
   - `db-data:/var/lib/postgresql/data` でマウント
   - PostgreSQL + Node.js API の 2 コンテナ構成で実践

8. **環境変数の外部化**
   - .env ファイルで機密情報を管理
   - docker-compose.yml では `${VARIABLE}` で参照
   - .gitignore に .env を追加（Git にコミットしない）

9. **AWS での対応関係**
   - .env → Secrets Manager / Parameter Store
   - Secrets Manager: 自動ローテーション、RDS 連携
   - Parameter Store: 無料、軽い機密情報向け

**作成したファイル:**
- `projects/container-basics/day48-volumes/docker-compose.yml`
- `projects/container-basics/day48-volumes/.env`
- `projects/container-basics/day48-volumes/.gitignore`
- `projects/container-basics/day48-volumes/app/Dockerfile`
- `projects/container-basics/day48-volumes/app/package.json`
- `projects/container-basics/day48-volumes/app/server.js`

**学んだコマンド:**
- `docker volume create`: ボリューム作成
- `docker volume ls`: ボリューム一覧
- `docker volume inspect`: ボリューム詳細
- `docker network inspect`: ネットワーク詳細（IP アドレス確認）
- `docker exec コンテナ名 cat /etc/resolv.conf`: DNS 設定確認
- `docker exec コンテナ名 nslookup サービス名`: 名前解決確認

**重要な学び:**
- Docker Volume は「永続化」は可能だが「可用性・耐障害性・運用性」が不足
- 開発環境: Docker Volume で十分
- 本番環境: RDS, EFS, S3 などマネージドサービスを使用
- ポータビリティはコンテナ部分のみ（AWS 専用サービスは移行対象外）

**次回 Day 49:** Docker Compose 応用（ヘルスチェック、リソース制限）

---

## Day 49 (2026-02-01)

**テーマ:** Docker Compose 応用（ヘルスチェック、リソース制限）

**完了したこと:**

1. **depends_on だけでは不十分な問題を体験**
   - Day 48 のコードで backend が DB 接続エラーでクラッシュ
   - 原因: depends_on は「コンテナ起動」を待つだけ
   - PostgreSQL が「接続可能」になるまで待たない

2. **ヘルスチェックの実装**
   - `healthcheck` セクションで DB の接続可能状態を監視
   - `pg_isready` コマンドで PostgreSQL の状態を確認
   - `depends_on: condition: service_healthy` で healthy まで待機

3. **ヘルスチェック設定項目**
   - `test`: チェックコマンド（pg_isready）
   - `interval`: チェック間隔（5秒）
   - `timeout`: タイムアウト（5秒）
   - `retries`: 失敗許容回数（5回）
   - `start_period`: 猶予期間（10秒）

4. **リソース制限の実装**
   - `deploy.resources.limits`: 上限（超えると制限/OOM Kill）
   - `deploy.resources.reservations`: 予約（最低保証）
   - CPU: 0.5（50%）、メモリ: 256MB で設定

5. **ノイジーネイバー問題の理解**
   - 1つのコンテナの暴走が他を巻き込む問題
   - リソース制限で「使える量の上限」を決めて防止
   - ただし全体設計（キャパシティプランニング）は別の話
   - ECS Fargate はタスクごとに専用リソース確保で問題回避

6. **実測結果**
   - db: `Up 28 seconds (healthy)` ← ヘルスチェック成功
   - backend: `Up 22 seconds` ← db healthy 後に起動（6秒待機）
   - `docker stats`: MEM USAGE / LIMIT = 23.49MiB / 256MiB

**作成したファイル:**
- `projects/container-basics/day49-healthcheck/docker-compose.yml`
- `projects/container-basics/day49-healthcheck/.env`
- `projects/container-basics/day49-healthcheck/.gitignore`
- `projects/container-basics/day49-healthcheck/app/Dockerfile`
- `projects/container-basics/day49-healthcheck/app/package.json`
- `projects/container-basics/day49-healthcheck/app/server.js`

**学んだコマンド:**
- `docker stats --no-stream`: リソース使用状況を一度だけ表示

**ECS/Kubernetes との対応:**
| Docker Compose | ECS | Kubernetes |
|----------------|-----|------------|
| `limits.memory` | Task Definition `memory` | `resources.limits.memory` |
| `limits.cpus` | Task Definition `cpu` | `resources.limits.cpu` |
| `reservations` | Soft Limit | `resources.requests` |

**次回 Day 50:** 12-Factor App、コンテナ設計ベストプラクティス

---

## Day 50 (2026-02-02)

**テーマ:** 12-Factor App、コンテナ設計ベストプラクティス

**完了したこと:**

1. **12-Factor App 概要**
   - 2011年 Heroku 創業者が発表した SaaS 設計原則
   - クラウドネイティブ、コンテナ、マイクロサービスの基盤
   - 12原則のうち、コンテナで特に重要な4つに絞って学習

2. **原則3: Config（設定は環境変数で）**
   - イメージに機密情報を焼き込まない
   - 実行時に環境変数で注入
   - Day 48 で実践済み（.env + docker-compose.yml）

3. **原則6: Processes（ステートレス）**
   - 状態はコンテナ内に持たない
   - セッション → Redis/DynamoDB
   - ファイル → S3/EFS
   - DB → RDS
   - スケール・障害復旧・デプロイが容易になる

4. **原則9: Disposability（即座に起動・停止）**
   - SIGTERM で graceful shutdown
   - Day 49 のヘルスチェックと関連

5. **原則11: Logs（stdout/stderr へ出力）**
   - ファイルに書かない（コンテナは揮発性）
   - console.log → docker logs → CloudWatch Logs

6. **CMD の書き方と PID 1 問題**
   - exec form: `CMD ["node", "server.js"]` → node が PID 1
   - shell form: `CMD node server.js` → sh が PID 1、node は子プロセス
   - docker stop は PID 1 に SIGTERM を送る
   - shell form だと sh が SIGTERM を子プロセスに転送しない
   - → node は SIGTERM を受け取れず、SIGKILL で強制終了
   - **結論: 常に exec form（配列形式）を使う**

7. **SIGTERM vs SIGKILL**
   - SIGTERM: 終了のお願い、プロセス側で処理可能（後片付けできる）
   - SIGKILL: 強制終了、プロセス側で処理不可能（即死）
   - docker stop: SIGTERM → 10秒待機 → SIGKILL

8. **Graceful Shutdown 実装パターン**
   ```javascript
   process.on('SIGTERM', () => {
     server.close(() => process.exit(0));
   });
   ```

**コンテナ設計チェックリスト:**
- [ ] 設定は環境変数で注入
- [ ] イメージに機密情報を焼き込まない
- [ ] ログは stdout/stderr
- [ ] CMD は exec form（配列形式）
- [ ] SIGTERM で graceful shutdown
- [ ] ヘルスチェック実装
- [ ] 状態は外部（RDS, S3, Redis）に保存

**Forbes 記事との関連:**
- 「従業員ゼロで1.5億円ビジネス」→ システムでレバレッジ
- 12-Factor App = スケールするシステムの設計原則
- 200日チャレンジで学ぶスキル = 一人で大きな価値を生む基盤

**次回 Day 51:** ECR（Elastic Container Registry）入門

---

## Day 51 (2026-02-03)

**テーマ:** ECR（Elastic Container Registry）入門

**完了したこと:**

1. **ECR の基本概念**
   - AWS のプライベート Docker レジストリ
   - Docker Hub との違い（IAM 認証、VPC 内通信、脆弱性スキャン）
   - 料金: ストレージ $0.10/GB/月 + データ転送

2. **ECR リポジトリを Terraform で作成**
   - `image_tag_mutability`: MUTABLE（タグ上書き可）vs IMMUTABLE
   - `scan_on_push`: プッシュ時に自動脆弱性スキャン
   - ライフサイクルポリシー: 最新5イメージを保持、古いものは自動削除

3. **ECR へのプッシュ実践**
   - `aws ecr get-login-password` で認証トークン取得
   - `docker build` → `docker tag` → `docker push`
   - PowerShell でのパイプ問題: 変数経由で解決

4. **CVE データベースの理解**
   - CVE = Common Vulnerabilities and Exposures（共通脆弱性識別子）
   - ウイルスではなく「ソフトウェアの弱点」のカタログ
   - ECR スキャン: イメージ内パッケージと CVE DB を照合

5. **リポジトリの役割の違いを理解**
   - GitHub リポジトリ: ソースコードを開発者間で共有
   - ECR リポジトリ: ビルド済みイメージを本番/検証用に保管
   - 「設計図の共有」vs「完成品の倉庫」

6. **開発フローの全体像**
   - 開発者: Git pull → docker build（各自ビルド）
   - 本番: CI/CD で自動ビルド → ECR → ECS（Phase 4 で学習）

**作成したファイル:**
- `projects/container-basics/day51-ecr/terraform/main.tf`
- `projects/container-basics/day51-ecr/app/Dockerfile`
- `projects/container-basics/day51-ecr/app/server.js`
- `projects/container-basics/day51-ecr/app/package.json`

**作成した AWS リソース:**
- ECR リポジトリ: `day51-sample-app`
- ライフサイクルポリシー: 最新5イメージ保持

**学んだコマンド:**
- `aws ecr get-login-password`: ECR 認証トークン取得
- `aws ecr describe-images`: イメージ一覧
- `aws ecr describe-image-scan-findings`: スキャン結果確認
- `docker tag`: イメージにタグ付け
- `docker push`: イメージをレジストリにプッシュ

**次回 Day 52:** ECR 応用（複数タグ、イメージ管理）または ECS 入門

---

## Day 52 (2026-02-03)

**テーマ:** ECS 入門 + ECR 応用

**完了したこと:**

1. **ECS の基本概念**
   - Cluster: タスクを実行する論理的なグループ（環境やチーム単位）
   - Service: 特定アプリの運用管理者（Task 数を維持）
   - Task: Task Definition から起動した実体（≒ コンテナの実行単位）
   - Container: 実際に動くプロセス（1 Task に複数可能）
   - 起動タイプ: EC2（自分で管理）vs Fargate（サーバーレス）

2. **ECS 環境を Terraform で構築**
   - ECS Cluster + Service + Task Definition
   - IAM Role（Task Execution Role）
   - Security Group（ポート 3000 許可）
   - CloudWatch Logs（/ecs/day52-ecs-app）

3. **Fargate でコンテナ実行**
   - Day 51 の ECR イメージ（day51-sample-app:latest）を使用
   - Public IP 経由でアクセス確認（http://13.159.16.223:3000）
   - ヘルスチェック: HEALTHY 状態を確認

4. **トラブルシューティング**
   - CannotPullContainerError: latest タグがなかった
   - 解決: v1 イメージに latest タグを追加してプッシュ
   - alpine イメージに curl がない → wget を使用

5. **ECR 応用: タグ戦略**
   - latest: 開発用（本番では非推奨）
   - セマンティック: v1.2.0（リリース管理）
   - Git SHA: main-2744e73（コミットと紐付け）
   - 複数タグを同じイメージに付与可能

6. **ECR イメージ管理**
   - Tags: None = タグが外れた孤立イメージ
   - ライフサイクルポリシーで自動削除
   - 脆弱性スキャン: プッシュ時に CVE DB と照合

7. **コスト対応**
   - OpenSearch Serverless: 削除済み（$2.52/日 → $0）
   - ECS Fargate: 学習後に削除（時間課金のため）

**作成したファイル:**
- `projects/container-basics/day52-ecs/terraform/main.tf`
- `projects/container-basics/day52-ecs/terraform/variables.tf`
- `projects/container-basics/day52-ecs/terraform/outputs.tf`
- `projects/container-basics/day52-ecs/terraform/iam.tf`
- `projects/container-basics/day52-ecs/terraform/ecs.tf`

**作成した AWS リソース:**
- ECS Cluster: day52-ecs-app-cluster（削除済み）
- ECS Service: day52-ecs-app-service（削除済み）
- Task Definition: day52-ecs-app
- ECR タグ追加: main-2744e73, latest

**学んだコマンド:**
- `aws ecs list-tasks --cluster`: タスク一覧
- `aws ecs describe-tasks`: タスク詳細
- `aws ecs describe-services --query 'services[0].events'`: サービスイベント
- `aws ecs update-service --force-new-deployment`: 強制再デプロイ
- `aws ecr start-image-scan`: 手動スキャン開始

**構造化の理解:**
- 全体を分けてつなぐ = ECS の階層構造（Cluster → Service → Task → Container）
- 各要素の役割を明確に分解することで理解が深まる

**次回 Day 53:** ECS 応用（ALB 連携、Auto Scaling）

---

---

# Side Project: Wizardry Schema

> 放置型RPG開発プロジェクト（AWS学習とは別枝）

---

## Game Day 1 (2026-02-03)

**テーマ:** ゲーム開発 - Wizardry Schema 放置型RPG

**完了したこと:**

1. **Wizardry Schema リサーチ**
   - オリジナル: GMO Gamepot (2014-2017)
   - 「ログを見るゲーム」放置型探索RPG
   - ダンジョン、種族、属性、職業システム
   - 有名フレーズ: 「ささやき－いのり－えいしょう－ねんじろ！」

2. **GitHub 類似プロジェクト調査**
   - miktaew/yet-another-idle-rpg: 放置型RPG（JS）
   - achiwa912/daemonlord: Wizardry風RPG + Rogue-lite（Python）
   - davemoore22/sorcery: Wizardry#1 リメイク（C++）
   - **Wizardry Schema クローンは見つからず → オリジナル性あり**

3. **v3.0 実装（他プロジェクトの良い要素を取り込み）**
   - 🎵 **BGM/効果音** (Tone.js) - レトロ風自動生成音楽
   - ⚔️ **Wizardry風呪文システム** - ハリト/マハリト/ディオス等
   - 📜 **クエストシステム** - 6クエスト + 報酬
   - 📖 **モンスター図鑑** - 遭遇記録、達成率表示
   - 🛒 **ボルタック商店** - 装備購入、装備管理
   - 🎯 **宝箱トラップ** - 7種類、盗賊で回避率UP
   - ⚙️ **設定パネル** - BGM/効果音 ON/OFF
   - 💾 **エクスポート/インポート** - セーブデータバックアップ

4. **ゲームシステム**
   - 5種族: 人間/エルフ/ドワーフ/ノーム/ポークル
   - 8職業: 戦士/魔術師/僧侶/盗賊/司教/侍/君主/忍者
   - 3属性: 秩序/中立/混沌（職業制限あり）
   - 8ダンジョン: スライムの穴 ～ トレボーの試練場
   - 30種類以上のモンスター（ワードナ含む）

**技術スタック:**
- React 18 (CDN)
- Tone.js (Web Audio API)
- Tailwind CSS
- LocalStorage (セーブ)

**参考にした要素:**
| 元プロジェクト | 取り込んだ要素 |
|---------------|---------------|
| yet-another-idle-rpg | 設定パネル、図鑑、エクスポート/インポート |
| daemonlord | 呪文システム、トラップ、詳細ステータス |

**作成したファイル:**
- `projects/game/wizardry-schema.html` (1283行)

**学び:**
- 既存OSSを調査し、良い要素を取り込む開発手法
- Tone.js でブラウザ内で音楽生成
- ゲームの状態管理（React Hooks）

---

## Game Day 2 (2026-02-03)

**テーマ:** Wizardry Schema v8.0 - バトル修正＆装備品拡充

**完了したこと:**

1. **バトル処理修正**
   - 探索ループのロジックをシンプル化
   - `setParty`内の複雑な処理を分離
   - バトルログを順次表示（150ms間隔）
   - MP消費とダメージを一括処理
   - `useCallback`で`addLog`を最適化

2. **装備品 200+アイテム追加**

   | カテゴリ | Common | Uncommon | Rare | Epic | Legendary | 計 |
   |---------|--------|----------|------|------|-----------|----|
   | 武器    | 20     | 25       | 20   | 12   | 10        | 87 |
   | 防具    | 20     | 22       | 15   | 10   | 8         | 75 |
   | 装飾品  | 10     | 15       | 12   | 8    | 6         | 51 |
   | 消耗品  | 2      | 2        | 2    | 2    | -         | 8  |
   | **合計**| 52     | 64       | 49   | 32   | 24        | **221** |

3. **主な装備品（レジェンダリー）**
   - **武器:** 妖刀ムラマサ(ATK55), ラグナロク(ATK60), アルテマウェポン(ATK65), 魔剣ダーインスレイヴ(ATK68)
   - **防具:** ガーディアンアーマー(DEF40), 天照の大鎧(DEF45), 神々の鎧(DEF50)
   - **装飾品:** 王の証(ATK/DEF+10), インフィニティガントレット(ATK/DEF+15)

4. **ボリューム調整機能**
   - BGM音量スライダー (0-100%)
   - 効果音音量スライダー (0-100%)
   - 設定はLocalStorageに保存

**修正した問題:**
- エンカウントしても戦闘が発生しない問題
  - 原因: `setParty`内のクロージャ問題
  - 解決: 探索ループを同期処理に変更、stateを直接参照

**ファイル更新:**
- `projects/game/wizardry-schema.html` (v8.0)

**学び:**
- React useEffect内でのクロージャ問題の回避方法
- 複雑なバトルロジックはsetState外で処理
- 大量のアイテムデータの効率的な管理（レアリティ分類）

---

## Game Day 3 - 2026/02/03

### Wizardry Schema v10.0 & v11.0 - 戦闘強化＆素材種類大幅拡充

**進捗:**

1. **v10.0 戦闘描写強化**
   - ターン制表示（【ターン1】【ターン2】...）
   - エンカウント描写パターン追加（6種）
   - 攻撃描写パターン追加（9種）
   - 敵HP状態表示（戦闘中）
   - UIレイアウト変更: 迷宮入り口(左) / 冒険記録(右)
   - 戦闘確率UP: 75%→85%
   - ボス専用ドロップ23種追加
   - レジェンダリー超レア化: 0.1%→0.02%

2. **v11.0 素材種類大幅拡充（450+アイテム）**

   **木材の種類（柔→硬）:**
   | 素材 | 特徴 | レアリティ |
   |------|------|------------|
   | 柳 | 最弱・しなやか | Common |
   | 樺 | 軽い | Common |
   | 松 | バランス | Common |
   | 楢 | やや硬い | Common |
   | 樫 | 硬い・高品質 | Common |
   | 黒檀 | 高級木材 | Uncommon |
   | 世界樹 | 神話級（ミスリル相当） | Epic-Legendary |

   **骨の種類（動物→神話）:**
   | 素材 | 特徴 | レアリティ |
   |------|------|------------|
   | ネズミ | 最弱 | Common |
   | 狼 | 鋭い | Common |
   | 熊 | 頑丈 | Common |
   | 牛 | 大型・重い | Common |
   | トロール | モンスター骨 | Uncommon |
   | ワイバーン | 飛竜骨 | Rare |
   | ドラゴン | 竜骨 | Rare |
   | 巨人 | 超大型 | Epic |
   | 神獣 | 神話級（オリハルコン級以上） | Legendary |

   **銅の種類:**
   - 粗銅（低品質）→ 精銅（標準）→ 赤銅 → 白銅（高品質合金）

   **鉄の種類:**
   - 粗鉄 → 錬鉄 → 玉鋼（日本刀用）→ ダマスカス鋼（伝説）→ 隕鉄（天鉄・魔力付与）

3. **最強武器ランキング**
   | 武器名 | ATK | 価格 | レアリティ |
   |--------|-----|------|------------|
   | 神殺しの剣 | 99 | 999,999G | Legendary |
   | 魔剣ダーインスレイヴ | 90 | 400,000G | Legendary |
   | アルテマウェポン | 85 | 300,000G | Legendary |
   | ラグナロク | 78 | 200,000G | Legendary |
   | 草薙剣 | 75 | 180,000G | Legendary |

**コミット:**
- `feat: Wizardry Schema v10.0 - 戦闘描写強化＆装備350+＆ボスドロップ拡充`
- `feat: Wizardry Schema v11.0 - 素材種類大幅拡充（450+アイテム）`

**ファイル更新:**
- `projects/game/wizardry-schema.html` (v11.0)

**学び:**
- RPG素材システムの階層設計（現実世界→ファンタジー→神話）
- 木材・骨・金属それぞれの品質グラデーション
- ゲームバランスと素材レアリティの関係

---

## Game Day 4 - 2026/02/04

### Wizardry Schema v13.0 & v13.1 - UI/UX改善＆ゲームバランス強化

**Phase 1 (v13.0) - UI/UX改善:**

1. **フォントサイズ拡大**
   - 冒険記録: text-xs → text-sm
   - パーティステータス: text-xs → text-sm
   - タブボタン: text-xs → text-sm
   - タイトルボタン: text-lg, py-3
   - フロア表示: text-2xl → text-3xl

2. **戦闘ログ70%削減**
   - 移動描写: 削除（慎重に歩を進める...等）
   - 部屋描写: 削除（探索中の詳細描写）
   - 通常戦闘: 1行サマリー化
     - Before: 20行以上のターン制詳細ログ
     - After: `バブリースライム撃破 +8EXP +3G 会心1`
   - ボス戦: 詳細ログ維持（ターン制、HP表示等）
   - ログ保持数: 150 → 100

3. **ダンジョン踏破時の自動帰還**
   - 最終ボス撃破検出: `isFinalBoss = isBoss && floor === dngData.floors`
   - ファンファーレ: 7音上昇音 (C5→C7)
   - 踏破表示: `🏆 {dungeon名} 踏破！ 🏆`
   - 2秒後自動帰還（HP/MP全回復）
   - ダンジョン選択画面に🏆マーカー表示

**Phase 2 (v13.1) - ゲームバランス強化:**

1. **種族特性実装**

   | 種族 | 特性 | 効果 |
   |------|------|------|
   | 人間 | EXP+30% | 経験値1.3倍で成長速い |
   | エルフ | 魔法+20% | 呪文ダメージ1.2倍 |
   | ドワーフ | DEF+15% | 被ダメージ軽減 |
   | ノーム | 回避+10% | 攻撃回避確率UP |
   | ポークル | 回避+15%, 会心+5% | 攻守バランス型 |

2. **ボス戦一時停止（BossConfirmModal）**
   - ボス発見時に探索一時停止
   - ボスステータス表示（HP/ATK/DEF）
   - パーティHP状態表示
   - 選択肢: ⚔️戦う / 🏃撤退
   - 最終ボスは🏆マーク付き

3. **消耗品自動使用**
   - トリガー: HP30%以下
   - 優先順位: エリクサー > ハイポーション > ポーション
   - 使用時ログ: `💊 {name}が{potion}を使用 (+{heal}HP)`
   - 設定ON/OFF可能（設定パネル）
   - エリクサー追加（回復9999, 500G, Rare）

**技術的変更:**
- LocalStorage key: wizardrySchemaV12 → wizardrySchemaV13
- 新State: `paused`, `bossConfirm`, `autoPotion`
- useCallback: `useAutoPotion`
- 新コンポーネント: `BossConfirmModal`
- 種族データに`trait`プロパティ追加

**ファイル更新:**
- `projects/game/wizardry-schema.html` (v13.1)

**学び:**
- React state管理の設計（探索中の一時停止制御）
- ゲームバランス調整（種族特性で差別化）
- UXの重要性（情報密度 vs 可読性のトレードオフ）

---

## Game Day 5 - 2026/02/04

### Wizardry Schema v14.4 - バロック調BGM＆オープニング演出

**Phase 1 - SoundEngineリファクタリング:**

1. **ダンジョン別バロック調テーマ（9種）**
   | ダンジョン | テンポ | 特徴 |
   |------------|--------|------|
   | town | 3.5s | 穏やかなバロック |
   | slime | 3.2s | 明るい探索 |
   | kobold | 3.0s | 緊張感 |
   | thieves | 3.8s | 神秘的 |
   | sewer | 4.2s | 不気味 |
   | kaoka | 4.0s | 古代の神秘 |
   | deltis | 3.5s | 豪華 |
   | dragon | 4.5s | 荘厳 |
   | trebor | 5.0s | 絶望と希望 |

2. **コード進行システム**
   - 8コード基本進行 + 特殊変化球コード
   - 12回に1回、特殊コード＋メロディ音追加
   - バロック調オルガン風シンセ（PolySynth, sine波）

3. **changeBGM()メソッド追加**
   - 現在のテーマと同じなら何もしない
   - 異なるテーマならstartBGM()で切替

**Phase 2 - オープニング演出（44秒）:**

1. **ストーリーテキスト**
   - 27行の壮大なプロローグ
   - フェードイン・スクロールアニメーション
   - SKIP機能付き

2. **演出効果**
   - slowScroll: 45秒間のスクロール
   - textGlow: タイトル発光アニメーション
   - fadeIn: 各行のフェードイン

**Phase 3 - BGM切替（帰還時5パターン）:**

| シナリオ | トリガー | 実装箇所 |
|----------|----------|----------|
| 全滅 | HP全員0 | useEffect内 |
| HP撤退 | HP閾値以下 | useEffect内 |
| ダンジョンクリア | 最終ボス撃破 | setTimeout内 |
| ボス戦撤退 | 撤退ボタン | BossConfirmModal |
| 手動帰還 | 帰還ボタン | 探索画面 |

**技術的変更:**
- SoundEngine.themes: 9ダンジョン分のコード進行定義
- changeBGM(): テーマ切替用メソッド追加
- CSSアニメーション: slowScroll, textGlow, fadeIn追加
- STORYオブジェクト: opening配列（delay付きテキスト）

**ファイル更新:**
- `projects/game/wizardry-schema.html` (v14.4)

**学び:**
- 音楽生成システムの設計（コード進行ベース）
- ゲーム雰囲気とBGMテンポの関係
- オープニング演出のタイミング制御

---

## Game Day 6 - 2026/02/04

### Wizardry Schema v15.0 - ストーリーシステム実装

**ストーリー概要:**
- ワードナは「悪の魔術師」ではなく、深淵の門を押さえ続ける英雄
- 「スキーマ」は門を開く術ではなく、門を閉じるための術
- 1000年間孤独に世界を守り続けた男の物語
- 真の敵は「深淵の王」（続編への伏線）

**実装した機能:**

1. **NPCシステム**
   - セラフィナ（古代史研究者）: ギルドで会話可能
   - 進行度に応じたセリフ変化（4パターン）
   - 文書を集めると真実が明らかに

2. **ストーリーイベント**
   | ダンジョン | トリガー | イベント名 | 入手アイテム |
   |------------|-----------|------------|------------|
   | 盗賊のアジト | クリア時 | 王家の古文書 | 王家の古文書 |
   | カオカ遺跡 | B8F到達 | 謎の壁画 | 壁画の写し |
   | 黄龍の神殿 | ボス戦前 | 竜の言葉 | - |
   | トレボー | ボス戦前 | ワードナの真実 | ワードナの日記 |

3. **エンディングシーケンス**
   - ワードナ撃破後の選択画面
   - 「見逃す」選択で真のエンディングへ
   - ポストクレジット: 深淵の王の伏線
   - 「Wizardry Schema 2 - Coming Soon...」

4. **UIコンポーネント**
   - DialogueModal: NPC会話表示
   - StoryEventModal: イベント発見表示
   - EndingScreen: エンディング演出

5. **ステート管理**
   - storyFlags: metSeraphina, documents[], eventsTriggered[], endingReached
   - LocalStorageキー: wizardrySchemaV15

**技術的変更:**
- 探索ループ内でストーリーイベントをトリガー
- ボス戦前・クリア時・階層到達時の3種のトリガー対応
- モーダル閉じる時の探索再開制御

**ファイル更新:**
- `projects/game/wizardry-schema.html` (v15.0)

**学び:**
- ゲームのストーリーは歴史の「再解釈」で深みが出る
- 悪役を英雄として描く視点の反転
- 続編への伏線はプレイヤーの期待を維持する

---

## Game Day 7: プレステージ（転生）システム実装

**日付:** 2026-02-04

**概要:**
idleゲームの最新トレンドをリサーチし、プレステージ（転生）システムを実装。
「スクラップ＆ビルド」方式でまず作る。

**リサーチ結果 (2025-2026年のidleゲームトレンド):**
- ✘ オフライン報酬（2013年頃からの古い手法）
- ✔ 多層プレステージシステムが核心
- ✔ プレステージを「罰」ではなく「報酬」に
- ✔ ストーリーとプレステージの融合

**実装内容:**

| 項目 | 詳細 |
|------|------|
| トリガー | ワードナ撃破後の選択画面 |
| リセット内容 | キャラ・ゴールド・装備・進行度・ストーリー |
| 永続ボーナス | 転生1回ごとにEXP/Gold +10% |
| UI表示 | ステータスバーに転生回数表示 |

**コード変更:**
```javascript
// プレステージstate
 const [prestige, setPrestige] = useState({ count: 0, totalClears: 0 });

// EXP/Goldにボーナス適用
const prestigeBonus = 1 + prestige.count * 0.1;
const expGain = Math.floor((mon.exp / alive.length) * (1 + expBonus) * prestigeBonus);
```

**ファイル更新:**
- `projects/game/wizardry-schema.html` (v15.0 → v16.0)

**学び:**
- idleゲームのオフライン報酬は古い手法になりつつある
- プレステージは「罰」ではなく「報酬」に感じさせるのが重要
- スクラップ＆ビルド方式でまず作る

---

<!-- 以下、Game Day 8〜 を追記していく -->
