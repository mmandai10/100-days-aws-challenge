<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wizardry Schema - æ”¾ç½®å‹æ¢ç´¢RPG</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
    body {
      font-family: 'DotGothic16', sans-serif;
      background-color: #0a0a0a;
      color: #33ff33;
    }
    .retro-border {
      border: 2px solid #33ff33;
      box-shadow: 0 0 10px rgba(51, 255, 51, 0.3);
    }
    .log-scroll::-webkit-scrollbar { width: 8px; }
    .log-scroll::-webkit-scrollbar-track { background: #1a1a1a; }
    .log-scroll::-webkit-scrollbar-thumb { background-color: #33ff33; }
    .blink { animation: blink 1s infinite; }
    @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }
    .gold-text { color: #ffd700; }
    .red-text { color: #ff4444; }
    .blue-text { color: #44aaff; }
    .purple-text { color: #aa44ff; }
    .tab-btn { transition: all 0.2s; }
    .tab-btn:hover { background-color: #1a4a1a; }
    .tab-btn.active { background-color: #2a5a2a; border-color: #66ff66; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // ===== ã‚µã‚¦ãƒ³ãƒ‰ã‚¨ãƒ³ã‚¸ãƒ³ (Tone.js) =====
    class SoundEngine {
      constructor() {
        this.initialized = false;
        this.bgmEnabled = true;
        this.sfxEnabled = true;
        this.bgmVolume = -12;
        this.sfxVolume = -6;
        this.synth = null;
        this.bgmLoop = null;
        this.isPlaying = false;
      }

      async init() {
        if (this.initialized) return;
        await Tone.start();
        
        // BGMç”¨ã‚·ãƒ³ã‚»ï¼ˆãƒ¬ãƒˆãƒ­é¢¨ï¼‰
        this.bgmSynth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'square' },
          envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.5 }
        }).toDestination();
        this.bgmSynth.volume.value = this.bgmVolume;

        // åŠ¹æœéŸ³ç”¨ã‚·ãƒ³ã‚»
        this.sfxSynth = new Tone.Synth({
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 }
        }).toDestination();
        this.sfxSynth.volume.value = this.sfxVolume;

        // ãƒ‰ãƒ©ãƒ 
        this.noiseSynth = new Tone.NoiseSynth({
          noise: { type: 'white' },
          envelope: { attack: 0.005, decay: 0.1, sustain: 0 }
        }).toDestination();
        this.noiseSynth.volume.value = -20;

        this.initialized = true;
      }

      // ãƒ¬ãƒˆãƒ­é¢¨BGMãƒ‘ã‚¿ãƒ¼ãƒ³
      startBGM() {
        if (!this.initialized || !this.bgmEnabled || this.isPlaying) return;
        
        const melody = [
          ['E4', '8n'], ['G4', '8n'], ['A4', '8n'], ['B4', '8n'],
          ['A4', '8n'], ['G4', '8n'], ['E4', '4n'],
          ['D4', '8n'], ['E4', '8n'], ['G4', '8n'], ['A4', '8n'],
          ['G4', '8n'], ['E4', '8n'], ['D4', '4n'],
          ['E4', '8n'], ['D4', '8n'], ['C4', '8n'], ['D4', '8n'],
          ['E4', '4n'], ['G4', '4n'],
          ['A4', '8n'], ['G4', '8n'], ['E4', '8n'], ['D4', '8n'],
          ['E4', '2n']
        ];

        let index = 0;
        this.bgmLoop = new Tone.Loop((time) => {
          if (!this.bgmEnabled) return;
          const [note, duration] = melody[index % melody.length];
          this.bgmSynth.triggerAttackRelease(note, duration, time);
          index++;
        }, '8n').start(0);

        Tone.Transport.bpm.value = 100;
        Tone.Transport.start();
        this.isPlaying = true;
      }

      stopBGM() {
        if (this.bgmLoop) {
          this.bgmLoop.stop();
          Tone.Transport.stop();
          this.isPlaying = false;
        }
      }

      toggleBGM(enabled) {
        this.bgmEnabled = enabled;
        if (enabled && this.initialized) {
          this.startBGM();
        } else {
          this.stopBGM();
        }
      }

      // åŠ¹æœéŸ³
      playAttack() {
        if (!this.initialized || !this.sfxEnabled) return;
        this.sfxSynth.triggerAttackRelease('C5', '16n');
        setTimeout(() => this.sfxSynth.triggerAttackRelease('E5', '16n'), 50);
      }

      playHit() {
        if (!this.initialized || !this.sfxEnabled) return;
        this.noiseSynth.triggerAttackRelease('16n');
      }

      playLevelUp() {
        if (!this.initialized || !this.sfxEnabled) return;
        const notes = ['C5', 'E5', 'G5', 'C6'];
        notes.forEach((note, i) => {
          setTimeout(() => this.sfxSynth.triggerAttackRelease(note, '8n'), i * 100);
        });
      }

      playHeal() {
        if (!this.initialized || !this.sfxEnabled) return;
        this.sfxSynth.triggerAttackRelease('G5', '4n');
        setTimeout(() => this.sfxSynth.triggerAttackRelease('B5', '4n'), 150);
      }

      playGold() {
        if (!this.initialized || !this.sfxEnabled) return;
        this.sfxSynth.triggerAttackRelease('E6', '16n');
        setTimeout(() => this.sfxSynth.triggerAttackRelease('G6', '16n'), 80);
      }

      playDeath() {
        if (!this.initialized || !this.sfxEnabled) return;
        const notes = ['E4', 'D4', 'C4', 'B3'];
        notes.forEach((note, i) => {
          setTimeout(() => this.sfxSynth.triggerAttackRelease(note, '8n'), i * 200);
        });
      }

      playBossAppear() {
        if (!this.initialized || !this.sfxEnabled) return;
        const notes = ['C3', 'C3', 'G3', 'C3', 'G3', 'C4'];
        notes.forEach((note, i) => {
          setTimeout(() => this.sfxSynth.triggerAttackRelease(note, '8n'), i * 150);
        });
      }
    }

    const soundEngine = new SoundEngine();

    // ===== Wizardryé¢¨ ãƒ©ãƒ³ãƒ€ãƒ åå‰ç”Ÿæˆ =====
    const NAME_PARTS = {
      human: {
        prefix: ['ã‚¢ãƒ«', 'ãƒ™ãƒ«', 'ã‚«ã‚¤', 'ãƒ€ãƒ³', 'ã‚¨ãƒ«', 'ãƒ•ã‚£ãƒ³', 'ã‚¬ãƒ«', 'ãƒãƒ«', 'ã‚¤ãƒ«', 'ã‚¸ã‚§', 
                 'ã‚±ã‚¤', 'ãƒ¬ã‚ª', 'ãƒãƒ«', 'ãƒã‚¨', 'ã‚ªãƒ«', 'ãƒ‘ãƒ«', 'ã‚¯ã‚¨', 'ãƒ¬ã‚¤', 'ã‚»ãƒ«', 'ã‚¿ãƒ«'],
        suffix: ['ã‚¹', 'ãƒ³', 'ãƒ‰', 'ã‚¯', 'ãƒˆ', 'ãƒ«', 'ãƒ ', 'ãƒ•', 'ãƒªã‚¢', 'ãƒŠ', 
                 'ã‚·ã‚¢', 'ãƒ†ã‚£', 'ãƒ´ã‚£', 'ã‚¦ã‚¹', 'ã‚ªãƒ³', 'ã‚¢ã‚¹', 'ã‚¨ãƒ«', 'ã‚¤ãƒ³', 'ã‚¦ãƒ ', 'ã‚¢']
      },
      elf: {
        prefix: ['ã‚¨ã‚¢', 'ã‚»ãƒ¬', 'ã‚¬ãƒ©', 'ãƒ¬ã‚´', 'ã‚¢ãƒ©', 'ã‚¨ãƒ«', 'ãƒ•ã‚§ã‚¢', 'ã‚®ãƒ«', 'ãƒªãƒ³', 'ãƒ«ãƒ¼',
                 'ãƒŸã‚¹', 'ãƒ‹ãƒ ', 'ã‚ªãƒ­', 'ã‚µãƒ«', 'ã‚·ãƒ«', 'ã‚¿ã‚¦', 'ã‚¦ãƒ³', 'ãƒ´ã‚¡', 'ã‚¤ãƒ‰', 'ã‚»ã‚¢'],
        suffix: ['ã‚¦ã‚§ãƒ³', 'ãƒ‡ã‚£ãƒ«', 'ãƒ‰ãƒªã‚¨ãƒ«', 'ãƒ©ã‚¹', 'ãƒŸã‚¢', 'ãƒãƒ¼ãƒ«', 'ãƒªã‚ªãƒ³', 'ã‚¦ã‚£ãƒ³', 'ãƒŠã‚¹', 'ãƒ­ã‚¹',
                 'ãƒŸãƒ«', 'ãƒ‰ãƒ¼ãƒ«', 'ãƒ•ã‚£ãƒ³', 'ãƒªã‚¢', 'ãƒ‡ã‚£ã‚¢', 'ã‚¨ãƒ«', 'ã‚·ãƒ«', 'ãƒ‹ã‚¨ãƒ«', 'ãƒ´ã‚§ãƒ«', 'ã‚¦ã‚£ãƒ«']
      },
      dwarf: {
        prefix: ['ãƒ‰ã‚¥', 'ãƒãƒ«', 'ã‚®ãƒ ', 'ãƒˆãƒ¼', 'ãƒ–ãƒ­', 'ãƒ€ã‚¤', 'ãƒ•ã‚¡', 'ã‚°ãƒ­', 'ã‚«ã‚¶', 'ãƒ¢ãƒ¼',
                 'ãƒŠãƒ¼', 'ã‚ªãƒ¼', 'ã‚¹ãƒ', 'ã‚¦ãƒ«', 'ãƒ´ã‚¡ãƒ«', 'ãƒ‰ãƒ¯', 'ãƒœãƒ«', 'ã‚°ãƒ©', 'ãƒãƒ«', 'ãƒ ãƒ«'],
        suffix: ['ãƒªãƒ³', 'ã‚¤ãƒ³', 'ãƒª', 'ãƒ«', 'ãƒ ', 'ãƒ‰', 'ã‚°', 'ã‚¯', 'ãƒ³', 'ãƒ•',
                 'ãƒœãƒ«', 'ãƒ€ãƒ«', 'ã‚¬ãƒ«', 'ãƒŠãƒ«', 'ãƒãƒ«', 'ã‚«ãƒ«', 'ã‚¶ãƒ«', 'ãƒˆãƒ«', 'ãƒ´ãƒ«', 'ã‚ªãƒ«']
      },
      gnome: {
        prefix: ['ãƒ•ã‚£', 'ã‚¸ãƒ³', 'ãƒœãƒœ', 'ãƒ‹ãƒ ', 'ã‚¬ãƒ¼', 'ãƒ”ãƒƒ', 'ãƒ†ã‚£ãƒ³', 'ã‚¦ã‚£', 'ã‚¶ãƒ³', 'ãƒªãƒª',
                 'ãƒ¡ãƒª', 'ãƒãƒ', 'ã‚­ã‚­', 'ãƒ«ãƒ«', 'ãƒŸãƒŸ', 'ãƒãƒ', 'ã‚¿ã‚¿', 'ãƒ“ãƒ“', 'ã‚³ã‚³', 'ãƒ‡ã‚£ãƒ‡ã‚£'],
        suffix: ['ãƒƒã‚¯', 'ã‚¹', 'ãƒ–ãƒ«', 'ãƒ‰ãƒ«', 'ãƒªãƒƒã‚¯', 'ãƒã‚¹', 'ãƒˆãƒ³', 'ã‚ºãƒ«', 'ã‚²ãƒ«', 'ã‚¯ãƒ«',
                 'ãƒ³ã‚¯', 'ãƒƒãƒ—', 'ãƒƒãƒˆ', 'ãƒ³ã‚¹', 'ãƒ ã‚¹', 'ãƒ«ã‚¹', 'ãƒ³ãƒ—', 'ãƒ«ã‚¯', 'ãƒ«ãƒ‰', 'ãƒ³ãƒ‰']
      },
      porkul: {
        prefix: ['ãƒ‘ãƒƒ', 'ãƒ”ãƒƒ', 'ãƒ—ãƒ«', 'ãƒšã‚³', 'ãƒãƒ³', 'ãƒ›ãƒ“', 'ãƒ­ãƒ¼', 'ã‚µãƒ ', 'ãƒ•ãƒ­', 'ãƒ¡ãƒª',
                 'ãƒ“ãƒ«', 'ãƒœãƒ–', 'ãƒ€ãƒ‰', 'ãƒ•ã‚¡', 'ã‚¬ãƒ ', 'ãƒãƒ ', 'ãƒˆãƒ ', 'ã‚¦ã‚£ãƒ«', 'ãƒãƒ³', 'ã‚¿ãƒ³'],
        suffix: ['ãƒ‰', 'ãƒˆ', 'ãƒ³', 'ãƒ«', 'ã‚¹', 'ãƒœ', 'ã‚´', 'ãƒ­', 'ã‚¸ãƒ¼', 'ã‚·ãƒ¼',
                 'ãƒ”ãƒ³', 'ã‚­ãƒ³', 'ãƒªãƒ³', 'ãƒŸãƒ³', 'ãƒ†ã‚£ãƒ³', 'ã‚¦ã‚£ãƒ³', 'ãƒ‡ã‚£ãƒ³', 'ãƒ•ã‚£ãƒ³', 'ã‚¸ãƒ³', 'ãƒ“ãƒ³']
      }
    };

    const generateName = (race) => {
      const parts = NAME_PARTS[race] || NAME_PARTS.human;
      const prefix = parts.prefix[Math.floor(Math.random() * parts.prefix.length)];
      const suffix = parts.suffix[Math.floor(Math.random() * parts.suffix.length)];
      return prefix + suffix;
    };

    // ===== ã‚²ãƒ¼ãƒ å®šæ•° =====
    const RACES = {
      human: { name: 'äººé–“', str: 8, int: 8, pie: 5, vit: 8, agi: 8, luk: 9, desc: 'ä¸‡èƒ½å‹' },
      elf: { name: 'ã‚¨ãƒ«ãƒ•', str: 7, int: 10, pie: 10, vit: 6, agi: 9, luk: 6, desc: 'é­”æ³•ç³»å‘ã' },
      dwarf: { name: 'ãƒ‰ãƒ¯ãƒ¼ãƒ•', str: 10, int: 7, pie: 10, vit: 10, agi: 5, luk: 6, desc: 'å‰è¡›å‘ã' },
      gnome: { name: 'ãƒãƒ¼ãƒ ', str: 7, int: 7, pie: 10, vit: 8, agi: 10, luk: 7, desc: 'åƒ§ä¾¶å‘ã' },
      porkul: { name: 'ãƒãƒ¼ã‚¯ãƒ«', str: 5, int: 7, pie: 7, vit: 6, agi: 10, luk: 15, desc: 'ç›—è³Šå‘ã' }
    };

    const ALIGNMENTS = {
      lawful: { name: 'ç§©åº(L)', color: 'text-blue-400' },
      neutral: { name: 'ä¸­ç«‹(N)', color: 'text-gray-400' },
      chaotic: { name: 'æ··æ²Œ(C)', color: 'text-red-400' }
    };

    const JOBS = {
      fighter: { name: 'æˆ¦å£«', hpMod: 1.5, mpMod: 0.2, atkMod: 1.4, defMod: 1.3, align: ['lawful', 'neutral', 'chaotic'], spellType: null },
      mage: { name: 'é­”è¡“å¸«', hpMod: 0.6, mpMod: 1.8, atkMod: 0.6, defMod: 0.5, align: ['lawful', 'neutral', 'chaotic'], spellType: 'mage' },
      priest: { name: 'åƒ§ä¾¶', hpMod: 0.9, mpMod: 1.4, atkMod: 0.8, defMod: 0.9, align: ['lawful', 'chaotic'], spellType: 'priest' },
      thief: { name: 'ç›—è³Š', hpMod: 0.8, mpMod: 0.5, atkMod: 1.0, defMod: 0.7, align: ['neutral', 'chaotic'], spellType: null },
      bishop: { name: 'å¸æ•™', hpMod: 0.7, mpMod: 1.6, atkMod: 0.7, defMod: 0.6, align: ['lawful', 'chaotic'], spellType: 'both' },
      samurai: { name: 'ä¾', hpMod: 1.3, mpMod: 0.8, atkMod: 1.3, defMod: 1.1, align: ['lawful', 'neutral'], spellType: 'mage' },
      lord: { name: 'å›ä¸»', hpMod: 1.4, mpMod: 1.0, atkMod: 1.2, defMod: 1.2, align: ['lawful'], spellType: 'priest' },
      ninja: { name: 'å¿è€…', hpMod: 1.0, mpMod: 0.6, atkMod: 1.5, defMod: 0.8, align: ['chaotic'], spellType: null }
    };

    // Wizardryé¢¨å‘ªæ–‡ã‚·ã‚¹ãƒ†ãƒ 
    const SPELLS = {
      mage: [
        { name: 'ãƒãƒªãƒˆ', level: 1, mp: 2, effect: 'damage', power: 15, desc: 'å°ç‚ã‚’æ”¾ã¤' },
        { name: 'ãƒ¢ã‚°ãƒ¬ãƒ•', level: 1, mp: 2, effect: 'buff_def', power: 3, desc: 'é˜²å¾¡åŠ›ä¸Šæ˜‡' },
        { name: 'ã‚«ãƒ†ã‚£ãƒ', level: 2, mp: 3, effect: 'sleep', power: 40, desc: 'æ•µã‚’çœ ã‚‰ã›ã‚‹' },
        { name: 'ãƒ‡ã‚£ãƒ«ãƒˆ', level: 2, mp: 3, effect: 'debuff_def', power: 3, desc: 'æ•µã®é˜²å¾¡ä½ä¸‹' },
        { name: 'ã‚½ãƒ”ãƒƒã‚¯', level: 3, mp: 4, effect: 'identify', power: 0, desc: 'å®ç®±ã®ç½ ã‚’è¦‹ç ´ã‚‹' },
        { name: 'ãƒãƒãƒªãƒˆ', level: 3, mp: 5, effect: 'damage_all', power: 25, desc: 'ç«ç‚çƒã‚’æ”¾ã¤' },
        { name: 'ãƒªãƒˆã‚«ãƒ³', level: 5, mp: 7, effect: 'damage_all', power: 40, desc: 'å¤§ç«ç‚ã‚’æ”¾ã¤' },
        { name: 'ãƒ†ã‚£ãƒ«ãƒˆã‚¦ã‚§ã‚¤ãƒˆ', level: 7, mp: 15, effect: 'damage_all', power: 80, desc: 'æ ¸çˆ†ç™ºç´šã®ç ´å£Šå‘ªæ–‡' }
      ],
      priest: [
        { name: 'ãƒ‡ã‚£ã‚ªã‚¹', level: 1, mp: 2, effect: 'heal', power: 20, desc: 'HPå°å›å¾©' },
        { name: 'ãƒãƒ‡ã‚£ã‚ªã‚¹', level: 1, mp: 2, effect: 'damage', power: 12, desc: 'ç¥è–ãªãƒ€ãƒ¡ãƒ¼ã‚¸' },
        { name: 'ãƒŸãƒ«ãƒ¯', level: 1, mp: 2, effect: 'light', power: 0, desc: 'æ¢ç´¢åŠ¹ç‡ä¸Šæ˜‡' },
        { name: 'ãƒãƒ«ãƒ•ã‚£ã‚¯', level: 2, mp: 3, effect: 'buff_def', power: 5, desc: 'å…¨ä½“é˜²å¾¡ä¸Šæ˜‡' },
        { name: 'ãƒãƒ‡ã‚£', level: 3, mp: 5, effect: 'heal', power: 50, desc: 'HPä¸­å›å¾©' },
        { name: 'ãƒ‡ã‚£ã‚¢ãƒ«', level: 4, mp: 6, effect: 'heal_all', power: 30, desc: 'å…¨ä½“HPå›å¾©' },
        { name: 'ãƒ©ãƒ„ãƒ¢ãƒ•ã‚£ã‚¹', level: 5, mp: 8, effect: 'cure_poison', power: 0, desc: 'æ¯’ã‚’æ²»ç™‚' },
        { name: 'ãƒãƒ‡ã‚£ã‚¢ãƒ«', level: 6, mp: 12, effect: 'heal_all', power: 60, desc: 'å…¨ä½“å¤§å›å¾©' },
        { name: 'ã‚«ãƒ‰ãƒ«ãƒˆ', level: 7, mp: 15, effect: 'resurrect', power: 50, desc: 'è˜‡ç”Ÿï¼ˆæˆåŠŸç‡50%ï¼‰' }
      ]
    };

    // è£…å‚™å“
    const ITEMS = {
      weapons: [
        { id: 'sword1', name: 'ãƒ­ãƒ³ã‚°ã‚½ãƒ¼ãƒ‰', atk: 5, price: 100, minLv: 1 },
        { id: 'sword2', name: 'ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚½ãƒ¼ãƒ‰', atk: 10, price: 300, minLv: 3 },
        { id: 'katana1', name: 'æ‰“åˆ€', atk: 15, price: 600, minLv: 5, jobs: ['samurai', 'ninja'] },
        { id: 'mace1', name: 'ãƒ¡ã‚¤ã‚¹', atk: 8, price: 200, minLv: 2, jobs: ['priest', 'lord'] },
        { id: 'staff1', name: 'æ–', atk: 3, price: 50, minLv: 1, jobs: ['mage', 'bishop'] },
        { id: 'dagger1', name: 'ãƒ€ã‚¬ãƒ¼', atk: 4, price: 80, minLv: 1 },
        { id: 'sword3', name: 'ãƒ•ãƒ¬ã‚¤ãƒ ã‚½ãƒ¼ãƒ‰', atk: 25, price: 1500, minLv: 10 },
        { id: 'katana2', name: 'æ‘æ­£', atk: 40, price: 5000, minLv: 15, jobs: ['samurai', 'ninja'] },
        { id: 'muramasa', name: 'å¦–åˆ€ãƒ ãƒ©ãƒã‚µ', atk: 60, price: 15000, minLv: 20, jobs: ['samurai', 'ninja'], cursed: true }
      ],
      armors: [
        { id: 'cloth1', name: 'å¸ƒã®æœ', def: 2, price: 50, minLv: 1 },
        { id: 'leather1', name: 'é©é§', def: 5, price: 150, minLv: 1 },
        { id: 'chain1', name: 'ãƒã‚§ã‚¤ãƒ³ãƒ¡ã‚¤ãƒ«', def: 10, price: 400, minLv: 3, jobs: ['fighter', 'lord', 'samurai'] },
        { id: 'plate1', name: 'ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ¡ã‚¤ãƒ«', def: 18, price: 1000, minLv: 5, jobs: ['fighter', 'lord'] },
        { id: 'robe1', name: 'ãƒ­ãƒ¼ãƒ–', def: 3, price: 100, minLv: 1, jobs: ['mage', 'bishop', 'priest'] },
        { id: 'ninja1', name: 'å¿ã³è£…æŸ', def: 8, price: 500, minLv: 5, jobs: ['ninja', 'thief'] },
        { id: 'dragonmail', name: 'ãƒ‰ãƒ©ã‚´ãƒ³ãƒ¡ã‚¤ãƒ«', def: 30, price: 5000, minLv: 15 }
      ],
      accessories: [
        { id: 'ring1', name: 'åŠ›ã®æŒ‡è¼ª', atk: 3, price: 500, minLv: 3 },
        { id: 'ring2', name: 'å®ˆã‚Šã®æŒ‡è¼ª', def: 3, price: 500, minLv: 3 },
        { id: 'amulet1', name: 'å¹¸é‹ã®ã‚¢ãƒŸãƒ¥ãƒ¬ãƒƒãƒˆ', luk: 5, price: 800, minLv: 5 },
        { id: 'ring3', name: 'å†ç”Ÿã®æŒ‡è¼ª', regen: 2, price: 2000, minLv: 10 }
      ]
    };

    // ã‚¯ã‚¨ã‚¹ãƒˆ
    const QUESTS = [
      { id: 'q1', name: 'ã¯ã˜ã‚ã¦ã®å†’é™º', desc: 'ã‚¹ãƒ©ã‚¤ãƒ ã®ç©´ã‚’B5Fã¾ã§è¸ç ´', condition: { dungeon: 'slime', floor: 5 }, reward: { gold: 500, exp: 200 } },
      { id: 'q2', name: 'ã‚³ãƒœãƒ«ãƒˆé€€æ²»', desc: 'ã‚³ãƒœãƒ«ãƒˆãƒ­ãƒ¼ãƒ‰ã‚’è¨ä¼', condition: { boss: 'ã‚³ãƒœãƒ«ãƒˆãƒ­ãƒ¼ãƒ‰' }, reward: { gold: 1000, exp: 500 } },
      { id: 'q3', name: 'ç›—è³Šå›£å£Šæ»…', desc: 'ç›—è³Šã®ã‚¢ã‚¸ãƒˆã‚’B10Fã¾ã§è¸ç ´', condition: { dungeon: 'thieves', floor: 10 }, reward: { gold: 2000, exp: 1000 } },
      { id: 'q4', name: 'ä¸‹æ°´é“ã®ææ€–', desc: 'ãƒ´ã‚¡ãƒ³ãƒ‘ã‚¤ã‚¢ã‚’è¨ä¼', condition: { boss: 'ãƒ´ã‚¡ãƒ³ãƒ‘ã‚¤ã‚¢' }, reward: { gold: 5000, exp: 2500 } },
      { id: 'q5', name: 'éºè·¡æ¢ç´¢', desc: 'ã‚«ã‚ªã‚«ãƒ»ãƒ‘ãƒ©ãƒ¼ã‚¸éºè·¡ã‚’B15Fã¾ã§è¸ç ´', condition: { dungeon: 'kaoka', floor: 15 }, reward: { gold: 8000, exp: 4000 } },
      { id: 'q6', name: 'ä¼èª¬ã®é­”ç‹', desc: 'ãƒ¯ãƒ¼ãƒ‰ãƒŠã‚’è¨ä¼', condition: { boss: 'ãƒ¯ãƒ¼ãƒ‰ãƒŠ' }, reward: { gold: 50000, exp: 30000 } }
    ];

    // Wizardry Schemaé¢¨ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³
    const DUNGEONS = [
      { id: 'slime', name: 'ã‚¹ãƒ©ã‚¤ãƒ ã®ç©´', floors: 5, minLv: 1 },
      { id: 'kobold', name: 'ã‚³ãƒœãƒ«ãƒ‰ã®å·£', floors: 8, minLv: 3 },
      { id: 'thieves', name: 'ç›—è³Šã®ã‚¢ã‚¸ãƒˆ', floors: 10, minLv: 5 },
      { id: 'sewer', name: 'ã‚«ãƒªã‚°ãƒ©ãƒ¼ã‚¼ä¸‹æ°´è·¯', floors: 12, minLv: 8 },
      { id: 'kaoka', name: 'ã‚«ã‚ªã‚«ãƒ»ãƒ‘ãƒ©ãƒ¼ã‚¸éºè·¡', floors: 15, minLv: 12 },
      { id: 'deltis', name: 'ãƒ‡ãƒ«ãƒ†ã‚£ã‚¹å¤§è”µå®¤', floors: 18, minLv: 16 },
      { id: 'dragon', name: 'é»„é¾ã®ç¥æ®¿è·¡', floors: 20, minLv: 20 },
      { id: 'trebor', name: 'ãƒˆãƒ¬ãƒœãƒ¼ã®è©¦ç·´å ´', floors: 25, minLv: 25 }
    ];

    const MONSTERS = [
      // ã‚¹ãƒ©ã‚¤ãƒ ã®ç©´
      { name: 'ãƒãƒ–ãƒªãƒ¼ã‚¹ãƒ©ã‚¤ãƒ ', hp: 12, atk: 4, def: 1, exp: 8, gold: 3, dungeon: 'slime', floor: 1 },
      { name: 'ã‚³ãƒœãƒ«ãƒˆ', hp: 18, atk: 6, def: 2, exp: 12, gold: 5, dungeon: 'slime', floor: 2 },
      { name: 'ã‚ªãƒ¼ã‚¯ãƒ™ãƒ“ãƒ¼', hp: 25, atk: 8, def: 3, exp: 18, gold: 8, dungeon: 'slime', floor: 3 },
      { name: 'ã‚¸ãƒ£ã‚¤ã‚¢ãƒ³ãƒˆãƒ©ãƒƒãƒˆ', hp: 20, atk: 10, def: 2, exp: 22, gold: 10, dungeon: 'slime', floor: 4 },
      { name: 'ã‚¹ãƒ©ã‚¤ãƒ ã‚­ãƒ³ã‚°', hp: 50, atk: 15, def: 5, exp: 50, gold: 30, dungeon: 'slime', floor: 5, boss: true },
      // ã‚³ãƒœãƒ«ãƒ‰ã®å·£
      { name: 'ã‚³ãƒœãƒ«ãƒˆã‚¦ã‚©ãƒ¼ãƒªã‚¢', hp: 30, atk: 12, def: 5, exp: 25, gold: 12, dungeon: 'kobold', floor: 1 },
      { name: 'ã‚³ãƒœãƒ«ãƒˆãƒ¡ã‚¤ã‚¸', hp: 22, atk: 18, def: 3, exp: 35, gold: 18, dungeon: 'kobold', floor: 3 },
      { name: 'ã‚ªãƒ¼ã‚¯', hp: 40, atk: 15, def: 6, exp: 40, gold: 20, dungeon: 'kobold', floor: 5 },
      { name: 'ã‚³ãƒœãƒ«ãƒˆãƒ­ãƒ¼ãƒ‰', hp: 80, atk: 25, def: 10, exp: 100, gold: 60, dungeon: 'kobold', floor: 8, boss: true },
      // ç›—è³Šã®ã‚¢ã‚¸ãƒˆ
      { name: 'ã‚·ãƒ¼ãƒ•', hp: 35, atk: 20, def: 6, exp: 40, gold: 25, dungeon: 'thieves', floor: 1 },
      { name: 'ã‚¢ã‚µã‚·ãƒ³', hp: 45, atk: 30, def: 8, exp: 60, gold: 40, dungeon: 'thieves', floor: 5 },
      { name: 'ãƒ€ãƒ¼ã‚¯ã‚¨ãƒ«ãƒ•', hp: 55, atk: 35, def: 10, exp: 80, gold: 50, dungeon: 'thieves', floor: 7 },
      { name: 'ãƒã‚¹ã‚¿ãƒ¼ã‚·ãƒ¼ãƒ•', hp: 120, atk: 40, def: 15, exp: 150, gold: 100, dungeon: 'thieves', floor: 10, boss: true },
      // ä¸‹æ°´è·¯
      { name: 'ã‚¾ãƒ³ãƒ“', hp: 55, atk: 15, def: 5, exp: 45, gold: 20, dungeon: 'sewer', floor: 1 },
      { name: 'ã‚¹ã‚±ãƒ«ãƒˆãƒ³', hp: 45, atk: 20, def: 8, exp: 50, gold: 25, dungeon: 'sewer', floor: 3 },
      { name: 'ã‚°ãƒ¼ãƒ«', hp: 65, atk: 25, def: 10, exp: 70, gold: 35, dungeon: 'sewer', floor: 5 },
      { name: 'ãƒ¯ã‚¤ãƒˆ', hp: 75, atk: 35, def: 12, exp: 90, gold: 50, dungeon: 'sewer', floor: 9 },
      { name: 'ãƒ´ã‚¡ãƒ³ãƒ‘ã‚¤ã‚¢', hp: 200, atk: 50, def: 20, exp: 250, gold: 150, dungeon: 'sewer', floor: 12, boss: true },
      // éºè·¡
      { name: 'ã‚¹ãƒˆãƒ¼ãƒ³ã‚´ãƒ¼ãƒ¬ãƒ ', hp: 100, atk: 40, def: 25, exp: 120, gold: 60, dungeon: 'kaoka', floor: 1 },
      { name: 'ã‚¬ãƒ¼ã‚´ã‚¤ãƒ«', hp: 90, atk: 50, def: 20, exp: 150, gold: 80, dungeon: 'kaoka', floor: 8 },
      { name: 'ã‚°ãƒ¬ãƒ¼ã‚¿ãƒ¼ãƒ‡ãƒ¼ãƒ¢ãƒ³', hp: 300, atk: 70, def: 30, exp: 400, gold: 250, dungeon: 'kaoka', floor: 15, boss: true },
      // å¤§è”µå®¤
      { name: 'ãƒŸãƒŸãƒƒã‚¯', hp: 80, atk: 45, def: 15, exp: 100, gold: 200, dungeon: 'deltis', floor: 1 },
      { name: 'ãƒãƒ³ãƒ†ã‚£ã‚³ã‚¢', hp: 150, atk: 60, def: 25, exp: 200, gold: 150, dungeon: 'deltis', floor: 10 },
      { name: 'ã‚´ãƒ¼ãƒ«ãƒ‰ãƒ‰ãƒ©ã‚´ãƒ³', hp: 400, atk: 80, def: 40, exp: 600, gold: 500, dungeon: 'deltis', floor: 18, boss: true },
      // ç¥æ®¿è·¡
      { name: 'ãƒ‰ãƒ©ã‚´ãƒ³ã‚¾ãƒ³ãƒ“', hp: 150, atk: 60, def: 20, exp: 200, gold: 100, dungeon: 'dragon', floor: 1 },
      { name: 'ãƒã‚¤ã‚ºãƒ³ã‚¸ãƒ£ã‚¤ã‚¢ãƒ³ãƒˆ', hp: 180, atk: 70, def: 25, exp: 280, gold: 140, dungeon: 'dragon', floor: 10 },
      { name: 'ã‚¨ãƒ³ã‚·ã‚§ãƒ³ãƒˆãƒ‰ãƒ©ã‚´ãƒ³', hp: 600, atk: 100, def: 50, exp: 1000, gold: 800, dungeon: 'dragon', floor: 20, boss: true },
      // ãƒˆãƒ¬ãƒœãƒ¼ã®è©¦ç·´å ´
      { name: 'ãƒˆãƒ¬ãƒœãƒ¼è¦ªè¡›éšŠ', hp: 200, atk: 80, def: 35, exp: 300, gold: 150, dungeon: 'trebor', floor: 1 },
      { name: 'ãƒ€ãƒ¼ã‚¯ãƒŠã‚¤ãƒˆ', hp: 250, atk: 90, def: 40, exp: 400, gold: 200, dungeon: 'trebor', floor: 15 },
      { name: 'ãƒ¯ãƒ¼ãƒ‰ãƒŠ', hp: 999, atk: 150, def: 60, exp: 5000, gold: 3000, dungeon: 'trebor', floor: 25, boss: true }
    ];

    // ãƒˆãƒ©ãƒƒãƒ—ä¸€è¦§
    const TRAPS = [
      { name: 'ãƒã‚¤ã‚ºãƒ³ãƒ‹ãƒ¼ãƒ‰ãƒ«', effect: 'poison', damage: 0.1 },
      { name: 'ã‚¯ãƒ­ã‚¹ãƒœã‚¦ãƒœãƒ«ãƒˆ', effect: 'damage', damage: 0.15 },
      { name: 'ã‚¹ã‚¿ãƒŠãƒ¼', effect: 'paralyze', damage: 0 },
      { name: 'çˆ†ç™ºã™ã‚‹ç®±', effect: 'damage_all', damage: 0.2 },
      { name: 'ã‚¬ã‚¹ãƒœãƒ ', effect: 'poison_all', damage: 0.05 },
      { name: 'ãƒ†ãƒ¬ãƒãƒ¼ã‚¿ãƒ¼', effect: 'teleport', damage: 0 },
      { name: 'ã‚¢ãƒ©ãƒ¼ãƒ ', effect: 'summon', damage: 0 }
    ];

    // æœ‰åãªWizardryãƒ•ãƒ¬ãƒ¼ã‚º
    const WIZ_PHRASES = [
      'ã•ã•ã‚„ãï¼ã„ã®ã‚Šï¼ãˆã„ã—ã‚‡ã†ï¼ã­ã‚“ã˜ã‚ï¼',
      'ãƒ‘ãƒ¼ãƒ†ã‚£ã¯æ…é‡ã«é€²ã‚“ã ...',
      'å®ç®±ã‚’ç™ºè¦‹ã—ãŸï¼',
      'ç½ ã ï¼æ°—ã‚’ã¤ã‘ã‚ï¼',
      'éšæ®µã‚’ç™ºè¦‹ã—ãŸ...',
      'ãƒ‘ãƒ¼ãƒ†ã‚£ã¯ä¼‘æ¯ã‚’ã¨ã£ãŸ',
      'æ³‰ã‚’ç™ºè¦‹ï¼ç¥ç§˜ã®æ°´ãŒæ¹§ã„ã¦ã„ã‚‹',
      'å£ã«ä½•ã‹æ›¸ã„ã¦ã‚ã‚‹..."TREBOR SUX"',
      'ãƒœãƒ«ã‚¿ãƒƒã‚¯å•†åº—ã®å•†äººã¨ã™ã‚Œé•ã£ãŸ',
      'ã‚«ãƒ³ãƒˆå¯ºé™¢ã®åƒ§ä¾¶ã®ç¥ˆã‚ŠãŒèã“ãˆã‚‹...'
    ];

    // ===== ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒª =====
    function App() {
      const [screen, setScreen] = useState('title');
      const [party, setParty] = useState([]);
      const [gold, setGold] = useState(100);
      const [logs, setLogs] = useState([]);
      const [exploring, setExploring] = useState(false);
      const [currentDungeon, setCurrentDungeon] = useState(null);
      const [currentFloor, setCurrentFloor] = useState(1);
      const [maxFloors, setMaxFloors] = useState({});
      const [retreatCondition, setRetreatCondition] = useState({ type: 'hp', value: 30 });
      const [activeTab, setActiveTab] = useState('party');
      const [settings, setSettings] = useState({ bgm: true, sfx: true });
      const [bestiary, setBestiary] = useState({});
      const [completedQuests, setCompletedQuests] = useState([]);
      const [defeatedBosses, setDefeatedBosses] = useState([]);
      const [inventory, setInventory] = useState([]);
      const [showShop, setShowShop] = useState(false);
      const [showSettings, setShowSettings] = useState(false);
      const logRef = useRef(null);

      // ã‚µã‚¦ãƒ³ãƒ‰åˆæœŸåŒ–
      const initSound = async () => {
        await soundEngine.init();
        if (settings.bgm) soundEngine.startBGM();
      };

      // ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰
      useEffect(() => {
        const saved = localStorage.getItem('wizardrySchemaV3');
        if (saved) {
          const data = JSON.parse(saved);
          setParty(data.party || []);
          setGold(data.gold || 100);
          setMaxFloors(data.maxFloors || {});
          setSettings(data.settings || { bgm: true, sfx: true });
          setBestiary(data.bestiary || {});
          setCompletedQuests(data.completedQuests || []);
          setDefeatedBosses(data.defeatedBosses || []);
          setInventory(data.inventory || []);
        }
      }, []);

      useEffect(() => {
        if (party.length > 0 || Object.keys(bestiary).length > 0) {
          localStorage.setItem('wizardrySchemaV3', JSON.stringify({ 
            party, gold, maxFloors, settings, bestiary, completedQuests, defeatedBosses, inventory 
          }));
        }
      }, [party, gold, maxFloors, settings, bestiary, completedQuests, defeatedBosses, inventory]);

      useEffect(() => {
        if (logRef.current) logRef.current.scrollTop = logRef.current.scrollHeight;
      }, [logs]);

      // BGMè¨­å®šå¤‰æ›´
      useEffect(() => {
        soundEngine.toggleBGM(settings.bgm);
      }, [settings.bgm]);

      const addLog = (message, type = 'normal') => {
        const colors = {
          normal: 'text-green-400',
          battle: 'text-yellow-400',
          damage: 'text-red-400',
          heal: 'text-blue-400',
          item: 'text-purple-400',
          level: 'text-cyan-400',
          special: 'text-pink-400',
          spell: 'text-orange-400'
        };
        setLogs(prev => [...prev.slice(-150), { message, color: colors[type], time: Date.now() }]);
      };

      // ã‚¯ã‚¨ã‚¹ãƒˆãƒã‚§ãƒƒã‚¯
      const checkQuests = useCallback((dungeon, floor, bossName = null) => {
        QUESTS.forEach(quest => {
          if (completedQuests.includes(quest.id)) return;
          
          let completed = false;
          if (quest.condition.dungeon && quest.condition.floor) {
            if (dungeon === quest.condition.dungeon && floor >= quest.condition.floor) {
              completed = true;
            }
          }
          if (quest.condition.boss && bossName === quest.condition.boss) {
            completed = true;
          }
          
          if (completed) {
            setCompletedQuests(prev => [...prev, quest.id]);
            setGold(prev => prev + quest.reward.gold);
            addLog(`ã€ã‚¯ã‚¨ã‚¹ãƒˆé”æˆã€‘${quest.name}ï¼`, 'level');
            addLog(`å ±é…¬: ${quest.reward.gold}G, ${quest.reward.exp}EXP`, 'item');
            soundEngine.playLevelUp();
            
            // çµŒé¨“å€¤åˆ†é…
            setParty(prev => prev.map(char => {
              const expPerChar = Math.floor(quest.reward.exp / prev.length);
              return { ...char, exp: char.exp + expPerChar };
            }));
          }
        });
      }, [completedQuests]);

      // å‘ªæ–‡ä½¿ç”¨
      const useSpell = useCallback((caster, spell, targets, isParty = false) => {
        if (caster.currentMp < spell.mp) return null;
        
        soundEngine.sfxSynth && soundEngine.playHeal();
        
        let result = { success: true, logs: [], mpUsed: spell.mp };
        
        switch (spell.effect) {
          case 'heal':
            if (isParty) {
              const target = targets[0];
              const healAmount = spell.power + Math.floor(caster.pie * 0.5);
              result.logs.push({ msg: `${caster.name}ãŒ${spell.name}ã‚’å”±ãˆãŸï¼`, type: 'spell' });
              result.logs.push({ msg: `${target.name}ã®HPãŒ${healAmount}å›å¾©ï¼`, type: 'heal' });
              result.healTarget = target.id;
              result.healAmount = healAmount;
            }
            break;
          case 'heal_all':
            const healAll = spell.power + Math.floor(caster.pie * 0.3);
            result.logs.push({ msg: `${caster.name}ãŒ${spell.name}ã‚’å”±ãˆãŸï¼`, type: 'spell' });
            result.logs.push({ msg: `å…¨å“¡ã®HPãŒ${healAll}å›å¾©ï¼`, type: 'heal' });
            result.healAll = healAll;
            break;
          case 'damage':
            const dmg = spell.power + Math.floor(caster.int * 0.5);
            result.logs.push({ msg: `${caster.name}ãŒ${spell.name}ã‚’å”±ãˆãŸï¼`, type: 'spell' });
            result.damage = dmg;
            break;
          case 'damage_all':
            const dmgAll = spell.power + Math.floor(caster.int * 0.3);
            result.logs.push({ msg: `${caster.name}ãŒ${spell.name}ã‚’å”±ãˆãŸï¼`, type: 'spell' });
            result.damageAll = dmgAll;
            break;
          default:
            result.logs.push({ msg: `${caster.name}ãŒ${spell.name}ã‚’å”±ãˆãŸï¼`, type: 'spell' });
        }
        
        return result;
      }, []);

      // æ¢ç´¢ãƒ«ãƒ¼ãƒ—
      useEffect(() => {
        if (!exploring || party.length === 0 || !currentDungeon) return;

        const interval = setInterval(() => {
          const aliveParty = party.filter(c => c.currentHp > 0);
          
          // é›¢è„±æ¡ä»¶ãƒã‚§ãƒƒã‚¯
          const shouldRetreat = aliveParty.some(c => {
            const hpPercent = (c.currentHp / c.maxHp) * 100;
            return hpPercent <= retreatCondition.value;
          });

          if (aliveParty.length === 0) {
            addLog('ã€å…¨æ»…ã€‘' + WIZ_PHRASES[0], 'damage');
            addLog('ãƒ‘ãƒ¼ãƒ†ã‚£ã¯è¡—ã«å¼·åˆ¶å¸°é‚„ã—ãŸ...', 'damage');
            soundEngine.playDeath();
            setExploring(false);
            setCurrentFloor(1);
            setParty(prev => prev.map(c => ({ ...c, currentHp: Math.floor(c.maxHp * 0.5) })));
            return;
          }

          if (shouldRetreat) {
            addLog(`ã€é›¢è„±æ¡ä»¶é”æˆã€‘HP${retreatCondition.value}%ä»¥ä¸‹ã®ãƒ¡ãƒ³ãƒãƒ¼ãŒã„ã¾ã™`, 'special');
            addLog('ãƒ‘ãƒ¼ãƒ†ã‚£ã¯å®‰å…¨ã«å¸°é‚„ã—ãŸ', 'heal');
            setExploring(false);
            setCurrentFloor(1);
            setParty(prev => prev.map(c => ({ ...c, currentHp: c.maxHp, currentMp: c.maxMp })));
            return;
          }

          // æ¢ç´¢ã‚¤ãƒ™ãƒ³ãƒˆ
          const event = Math.random();
          const dungeon = DUNGEONS.find(d => d.id === currentDungeon);

          if (event < 0.55) {
            // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼é­é‡
            const availableMonsters = MONSTERS.filter(m => 
              m.dungeon === currentDungeon && m.floor <= currentFloor
            );
            if (availableMonsters.length === 0) {
              addLog(`B${currentFloor}F: ${WIZ_PHRASES[1]}`, 'normal');
              return;
            }
            
            const monster = { ...availableMonsters[Math.floor(Math.random() * availableMonsters.length)] };
            const isBoss = monster.boss && currentFloor === monster.floor;
            
            if (isBoss) soundEngine.playBossAppear();
            addLog(`B${currentFloor}F: ${monster.name}${isBoss ? 'ã€BOSSã€‘' : ''}ãŒç¾ã‚ŒãŸï¼`, 'battle');
            
            // å›³é‘‘ã«è¿½åŠ 
            setBestiary(prev => ({
              ...prev,
              [monster.name]: { ...monster, encountered: (prev[monster.name]?.encountered || 0) + 1 }
            }));

            setTimeout(() => {
              let monsterHp = monster.hp;
              let battleLogs = [];
              
              // ãƒ‘ãƒ¼ãƒ†ã‚£ã®æ”»æ’ƒï¼ˆå‘ªæ–‡ä½¿ç”¨å«ã‚€ï¼‰
              aliveParty.forEach(char => {
                if (monsterHp <= 0) return;
                
                const job = JOBS[char.jobKey];
                const useSpellChance = job.spellType && char.currentMp >= 2 && Math.random() < 0.3;
                
                if (useSpellChance) {
                  // æ”»æ’ƒå‘ªæ–‡ã‚’ä½¿ç”¨
                  const spellList = job.spellType === 'both' 
                    ? [...SPELLS.mage, ...SPELLS.priest]
                    : SPELLS[job.spellType] || [];
                  
                  const attackSpells = spellList.filter(s => 
                    (s.effect === 'damage' || s.effect === 'damage_all') && 
                    s.mp <= char.currentMp &&
                    s.level <= Math.floor(char.level / 2) + 1
                  );
                  
                  if (attackSpells.length > 0) {
                    const spell = attackSpells[Math.floor(Math.random() * attackSpells.length)];
                    const damage = spell.power + Math.floor(char.int * 0.5);
                    monsterHp -= damage;
                    
                    setParty(prev => prev.map(c => 
                      c.id === char.id ? { ...c, currentMp: c.currentMp - spell.mp } : c
                    ));
                    
                    battleLogs.push({ msg: `${char.name}ã¯${spell.name}ã‚’å”±ãˆãŸï¼${damage}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, type: 'spell' });
                    soundEngine.playAttack();
                    return;
                  }
                }
                
                // é€šå¸¸æ”»æ’ƒ
                const baseDamage = char.atk - monster.def + Math.floor(Math.random() * 10);
                const damage = Math.max(1, baseDamage);
                monsterHp -= damage;
                battleLogs.push({ msg: `${char.name}ã®æ”»æ’ƒï¼${monster.name}ã«${damage}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, type: 'battle' });
                soundEngine.playAttack();
              });

              if (monsterHp <= 0) {
                battleLogs.push({ msg: `${monster.name}ã‚’å€’ã—ãŸï¼`, type: 'battle' });
                battleLogs.push({ msg: `${monster.exp}EXP, ${monster.gold}Gã‚’ç²å¾—ï¼`, type: 'item' });
                soundEngine.playGold();
                setGold(prev => prev + monster.gold);
                
                // ãƒœã‚¹è¨ä¼è¨˜éŒ²
                if (isBoss) {
                  setDefeatedBosses(prev => [...new Set([...prev, monster.name])]);
                  checkQuests(currentDungeon, currentFloor, monster.name);
                }
                
                // çµŒé¨“å€¤åˆ†é…ã¨ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
                setParty(prev => prev.map(char => {
                  if (char.currentHp <= 0) return char;
                  const expGain = Math.floor(monster.exp / aliveParty.length);
                  const newExp = char.exp + expGain;
                  const expNeeded = char.level * 100;
                  
                  if (newExp >= expNeeded) {
                    const hpGain = Math.floor(5 + char.vit * 0.5);
                    const mpGain = Math.floor(3 + char.int * 0.3);
                    battleLogs.push({ msg: `â˜… ${char.name}ã¯ãƒ¬ãƒ™ãƒ«${char.level + 1}ã«ä¸ŠãŒã£ãŸï¼`, type: 'level' });
                    soundEngine.playLevelUp();
                    return {
                      ...char,
                      exp: newExp - expNeeded,
                      level: char.level + 1,
                      maxHp: char.maxHp + hpGain,
                      currentHp: char.maxHp + hpGain,
                      maxMp: char.maxMp + mpGain,
                      currentMp: char.maxMp + mpGain,
                      atk: char.atk + 2,
                      def: char.def + 1
                    };
                  }
                  return { ...char, exp: newExp };
                }));
              } else {
                // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®åæ’ƒ
                soundEngine.playHit();
                const target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                const monsterDmg = Math.max(1, monster.atk - target.def + Math.floor(Math.random() * 8));
                
                setParty(prev => prev.map(char => {
                  if (char.id === target.id) {
                    const newHp = Math.max(0, char.currentHp - monsterDmg);
                    battleLogs.push({ msg: `${monster.name}ã®åæ’ƒï¼${char.name}ã«${monsterDmg}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`, type: 'damage' });
                    if (newHp === 0) {
                      battleLogs.push({ msg: `${char.name}ã¯å€’ã‚ŒãŸ...`, type: 'damage' });
                      soundEngine.playDeath();
                    }
                    return { ...char, currentHp: newHp };
                  }
                  return char;
                }));
              }

              battleLogs.forEach((log, i) => {
                setTimeout(() => addLog(log.msg, log.type), i * 200);
              });
            }, 400);

          } else if (event < 0.72) {
            // éšæ®µç™ºè¦‹
            if (currentFloor < dungeon.floors) {
              const newFloor = currentFloor + 1;
              setCurrentFloor(newFloor);
              setMaxFloors(prev => ({
                ...prev,
                [currentDungeon]: Math.max(prev[currentDungeon] || 0, newFloor)
              }));
              addLog(`${WIZ_PHRASES[4]} B${newFloor}Fã¸é™ã‚ŠãŸ...`, 'item');
              checkQuests(currentDungeon, newFloor);
            } else {
              addLog(`B${currentFloor}F: ${WIZ_PHRASES[1]}`, 'normal');
            }
          } else if (event < 0.85) {
            // å®ç®±
            const goldFound = Math.floor(Math.random() * 50 * currentFloor) + 10;
            addLog(`${WIZ_PHRASES[2]}`, 'item');
            
            // ç›—è³ŠãŒã„ã‚Œã°ç½ å›é¿ç‡ä¸Šæ˜‡
            const hasThief = aliveParty.some(c => c.jobKey === 'thief' || c.jobKey === 'ninja');
            const trapChance = hasThief ? 0.1 : 0.25;
            
            if (Math.random() < trapChance) {
              const trap = TRAPS[Math.floor(Math.random() * TRAPS.length)];
              addLog(`${WIZ_PHRASES[3]} ${trap.name}ï¼`, 'damage');
              soundEngine.playHit();
              
              if (trap.effect === 'damage' || trap.effect === 'damage_all') {
                const targets = trap.effect === 'damage_all' ? aliveParty : [aliveParty[Math.floor(Math.random() * aliveParty.length)]];
                setParty(prev => prev.map(c => {
                  if (targets.find(t => t.id === c.id)) {
                    const trapDmg = Math.floor(c.maxHp * trap.damage);
                    return { ...c, currentHp: Math.max(1, c.currentHp - trapDmg) };
                  }
                  return c;
                }));
              }
            } else {
              setGold(prev => prev + goldFound);
              addLog(`${goldFound}Gã‚’ç™ºè¦‹ï¼`, 'item');
              soundEngine.playGold();
              
              // ã¾ã‚Œã«ã‚¢ã‚¤ãƒ†ãƒ ãƒ‰ãƒ­ãƒƒãƒ—
              if (Math.random() < 0.1) {
                const allItems = [...ITEMS.weapons, ...ITEMS.armors, ...ITEMS.accessories];
                const availableItems = allItems.filter(item => item.minLv <= Math.floor(currentFloor / 2) + 1);
                if (availableItems.length > 0) {
                  const foundItem = availableItems[Math.floor(Math.random() * availableItems.length)];
                  setInventory(prev => [...prev, { ...foundItem, id: Date.now() }]);
                  addLog(`${foundItem.name}ã‚’ç™ºè¦‹ï¼`, 'item');
                }
              }
            }
          } else if (event < 0.92) {
            // å›å¾©ãƒã‚¤ãƒ³ãƒˆ
            addLog(WIZ_PHRASES[6], 'heal');
            soundEngine.playHeal();
            setParty(prev => prev.map(c => ({
              ...c,
              currentHp: Math.min(c.maxHp, c.currentHp + Math.floor(c.maxHp * 0.25)),
              currentMp: Math.min(c.maxMp, c.currentMp + Math.floor(c.maxMp * 0.25))
            })));
          } else {
            // ç‰¹æ®Šã‚¤ãƒ™ãƒ³ãƒˆ
            const phrase = WIZ_PHRASES[Math.floor(Math.random() * WIZ_PHRASES.length)];
            addLog(`B${currentFloor}F: ${phrase}`, 'special');
          }
        }, 1800);

        return () => clearInterval(interval);
      }, [exploring, party, currentFloor, currentDungeon, retreatCondition, checkQuests]);

      // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
      const exportSave = () => {
        const data = { party, gold, maxFloors, settings, bestiary, completedQuests, defeatedBosses, inventory };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `wizardry-schema-save-${Date.now()}.json`;
        a.click();
      };

      const importSave = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            setParty(data.party || []);
            setGold(data.gold || 100);
            setMaxFloors(data.maxFloors || {});
            setSettings(data.settings || { bgm: true, sfx: true });
            setBestiary(data.bestiary || {});
            setCompletedQuests(data.completedQuests || []);
            setDefeatedBosses(data.defeatedBosses || []);
            setInventory(data.inventory || []);
            alert('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
          } catch (err) {
            alert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ');
          }
        };
        reader.readAsText(file);
      };

      // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢
      if (screen === 'title') {
        return (
          <div className="min-h-screen flex flex-col items-center justify-center p-4">
            <div className="retro-border p-8 bg-black text-center max-w-md">
              <h1 className="text-3xl mb-2 gold-text">âš”ï¸ WIZARDRY SCHEMA âš”ï¸</h1>
              <p className="text-sm mb-2 text-gray-400">ã€œ ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³æ¢ç´¢å‹ãƒ­ã‚°RPG ã€œ</p>
              <p className="text-xs mb-6 text-gray-600">ã•ã•ã‚„ãï¼ã„ã®ã‚Šï¼ãˆã„ã—ã‚‡ã†ï¼ã­ã‚“ã˜ã‚ï¼</p>
              <div className="space-y-3">
                <button 
                  onClick={() => { setScreen('main'); initSound(); }}
                  className="block w-full retro-border px-6 py-2 hover:bg-green-900 transition"
                >
                  {party.length > 0 ? 'â–¶ CONTINUE' : 'â–¶ NEW GAME'}
                </button>
                {party.length > 0 && (
                  <>
                    <button 
                      onClick={exportSave}
                      className="block w-full retro-border px-6 py-2 hover:bg-blue-900 transition text-blue-400"
                    >
                      ğŸ“¤ EXPORT SAVE
                    </button>
                    <button 
                      onClick={() => {
                        if(confirm('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                          localStorage.removeItem('wizardrySchemaV3');
                          setParty([]);
                          setGold(100);
                          setMaxFloors({});
                          setBestiary({});
                          setCompletedQuests([]);
                          setDefeatedBosses([]);
                          setInventory([]);
                        }
                      }}
                      className="block w-full retro-border px-6 py-2 hover:bg-red-900 transition text-red-400"
                    >
                      â–¶ DELETE SAVE
                    </button>
                  </>
                )}
                <label className="block w-full retro-border px-6 py-2 hover:bg-purple-900 transition text-purple-400 cursor-pointer">
                  ğŸ“¥ IMPORT SAVE
                  <input type="file" accept=".json" onChange={importSave} className="hidden" />
                </label>
              </div>
              <p className="mt-6 text-xs text-gray-600">Â© 2026 Claude RPG Engine v3.0</p>
            </div>
          </div>
        );
      }

      // ã‚­ãƒ£ãƒ©ä½œæˆé–¢æ•°
      const createRandomCharacter = () => {
        if (party.length >= 6) return alert('ãƒ‘ãƒ¼ãƒ†ã‚£ã¯æœ€å¤§6äººã§ã™');
        
        const raceKeys = Object.keys(RACES);
        const raceKey = raceKeys[Math.floor(Math.random() * raceKeys.length)];
        const race = RACES[raceKey];
        
        const alignKeys = Object.keys(ALIGNMENTS);
        const alignKey = alignKeys[Math.floor(Math.random() * alignKeys.length)];
        
        const availableJobs = Object.entries(JOBS).filter(([_, job]) => job.align.includes(alignKey));
        const [jobKey, job] = availableJobs[Math.floor(Math.random() * availableJobs.length)];
        
        const bonusPoints = Math.floor(Math.random() * 15) + 5;
        const vit = race.vit + Math.floor(bonusPoints * 0.4);
        const int = race.int + Math.floor(bonusPoints * 0.2);
        
        const baseHp = Math.floor((vit * 3 + 20) * job.hpMod);
        const baseMp = Math.floor((int * 2 + 10) * job.mpMod);
        const baseAtk = Math.floor((race.str * 1.5 + 5) * job.atkMod);
        const baseDef = Math.floor((vit * 1.2 + 3) * job.defMod);

        const newChar = {
          id: Date.now(),
          name: generateName(raceKey),
          race: race.name,
          raceKey,
          alignment: ALIGNMENTS[alignKey].name,
          alignKey,
          job: job.name,
          jobKey,
          level: 1,
          exp: 0,
          maxHp: baseHp,
          currentHp: baseHp,
          maxMp: baseMp,
          currentMp: baseMp,
          atk: baseAtk,
          def: baseDef,
          str: race.str,
          int: int,
          pie: race.pie,
          vit: vit,
          agi: race.agi,
          luk: race.luk,
          equipment: { weapon: null, armor: null, accessory: null }
        };
        
        setParty(prev => [...prev, newChar]);
        addLog(`${newChar.name}ï¼ˆ${race.name}ã®${job.name}ï¼‰ãŒã‚®ãƒ«ãƒ‰ã«ç™»éŒ²ã•ã‚ŒãŸï¼`, 'level');
      };

      // è£…å‚™
      const equipItem = (charId, item, slot) => {
        setParty(prev => prev.map(char => {
          if (char.id !== charId) return char;
          
          // å¤ã„è£…å‚™ã‚’å¤–ã™
          const oldItem = char.equipment[slot];
          let newAtk = char.atk;
          let newDef = char.def;
          
          if (oldItem) {
            if (oldItem.atk) newAtk -= oldItem.atk;
            if (oldItem.def) newDef -= oldItem.def;
            setInventory(prev => [...prev, oldItem]);
          }
          
          // æ–°ã—ã„è£…å‚™ã‚’ä»˜ã‘ã‚‹
          if (item.atk) newAtk += item.atk;
          if (item.def) newDef += item.def;
          
          setInventory(prev => prev.filter(i => i.id !== item.id));
          
          return {
            ...char,
            atk: newAtk,
            def: newDef,
            equipment: { ...char.equipment, [slot]: item }
          };
        }));
        addLog(`${party.find(c => c.id === charId)?.name}ã¯${item.name}ã‚’è£…å‚™ã—ãŸ`, 'item');
      };

      // ãƒ¡ã‚¤ãƒ³ç”»é¢
      return (
        <div className="min-h-screen p-2">
          <div className="max-w-6xl mx-auto">
            {/* ãƒ˜ãƒƒãƒ€ãƒ¼ */}
            <div className="retro-border p-3 mb-3 flex justify-between items-center flex-wrap gap-2">
              <h1 className="text-lg gold-text">âš”ï¸ WIZARDRY SCHEMA</h1>
              <div className="flex gap-4 text-sm items-center">
                <span className="gold-text">ğŸ’° {gold.toLocaleString()} G</span>
                <button 
                  onClick={() => setShowSettings(!showSettings)}
                  className="text-gray-400 hover:text-white"
                >
                  âš™ï¸
                </button>
              </div>
            </div>

            {/* è¨­å®šãƒ‘ãƒãƒ« */}
            {showSettings && (
              <div className="retro-border p-3 mb-3 bg-gray-900">
                <h3 className="text-sm mb-2">è¨­å®š</h3>
                <div className="flex flex-wrap gap-4 text-xs">
                  <label className="flex items-center gap-2">
                    <input 
                      type="checkbox" 
                      checked={settings.bgm}
                      onChange={(e) => setSettings(prev => ({ ...prev, bgm: e.target.checked }))}
                    />
                    BGM
                  </label>
                  <label className="flex items-center gap-2">
                    <input 
                      type="checkbox" 
                      checked={settings.sfx}
                      onChange={(e) => {
                        setSettings(prev => ({ ...prev, sfx: e.target.checked }));
                        soundEngine.sfxEnabled = e.target.checked;
                      }}
                    />
                    åŠ¹æœéŸ³
                  </label>
                  <button onClick={exportSave} className="text-blue-400 hover:underline">
                    ğŸ“¤ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                  </button>
                </div>
              </div>
            )}

            {/* ã‚¿ãƒ–ãƒŠãƒ“ */}
            <div className="flex gap-1 mb-3 flex-wrap">
              {['party', 'dungeon', 'quest', 'bestiary', 'shop'].map(tab => (
                <button
                  key={tab}
                  onClick={() => setActiveTab(tab)}
                  className={`retro-border px-3 py-1 text-xs tab-btn ${activeTab === tab ? 'active' : ''}`}
                >
                  {{ party: 'ğŸ‘¥ ãƒ‘ãƒ¼ãƒ†ã‚£', dungeon: 'ğŸ° ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³', quest: 'ğŸ“œ ã‚¯ã‚¨ã‚¹ãƒˆ', bestiary: 'ğŸ“– å›³é‘‘', shop: 'ğŸ›’ ã‚·ãƒ§ãƒƒãƒ—' }[tab]}
                </button>
              ))}
            </div>

            <div className="grid lg:grid-cols-3 gap-3">
              {/* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */}
              <div className="lg:col-span-2 retro-border p-3">
                {activeTab === 'party' && (
                  <>
                    <h2 className="text-base mb-2 border-b border-green-800 pb-1">ã€ å†’é™ºè€…ã‚®ãƒ«ãƒ‰ ã€‘({party.length}/6)</h2>
                    <div className="grid md:grid-cols-2 gap-2 max-h-96 overflow-y-auto">
                      {party.map(char => (
                        <div key={char.id} className={`p-2 bg-gray-900 text-xs ${char.currentHp === 0 ? 'opacity-50' : ''}`}>
                          <div className="flex justify-between items-center">
                            <span className="font-bold text-sm">{char.name}</span>
                            <span className={ALIGNMENTS[char.alignKey]?.color || 'text-gray-400'}>{char.alignment}</span>
                          </div>
                          <div className="text-gray-400">
                            Lv.{char.level} {char.race} {char.job}
                          </div>
                          <div className="mt-1 grid grid-cols-2 gap-1">
                            <span className="red-text">HP:{char.currentHp}/{char.maxHp}</span>
                            <span className="blue-text">MP:{char.currentMp}/{char.maxMp}</span>
                            <span>ATK:{char.atk}</span>
                            <span>DEF:{char.def}</span>
                          </div>
                          <div className="w-full bg-gray-700 h-1 mt-1">
                            <div className="bg-red-500 h-1" style={{ width: `${(char.currentHp / char.maxHp) * 100}%` }}/>
                          </div>
                          <div className="w-full bg-gray-700 h-1 mt-1">
                            <div className="bg-blue-500 h-1" style={{ width: `${(char.currentMp / char.maxMp) * 100}%` }}/>
                          </div>
                          {/* è£…å‚™ã‚¹ãƒ­ãƒƒãƒˆ */}
                          <div className="mt-2 text-gray-500 text-[10px]">
                            <div>âš”ï¸ {char.equipment?.weapon?.name || 'æœªè£…å‚™'}</div>
                            <div>ğŸ›¡ï¸ {char.equipment?.armor?.name || 'æœªè£…å‚™'}</div>
                            <div>ğŸ’ {char.equipment?.accessory?.name || 'æœªè£…å‚™'}</div>
                          </div>
                        </div>
                      ))}
                    </div>
                    {!exploring && (
                      <div className="mt-3 flex gap-2 flex-wrap">
                        <button
                          onClick={createRandomCharacter}
                          disabled={party.length >= 6}
                          className="retro-border px-4 py-2 text-sm hover:bg-green-900 disabled:opacity-50"
                        >
                          ï¼‹ ãƒ©ãƒ³ãƒ€ãƒ å†’é™ºè€…
                        </button>
                        {party.length > 0 && (
                          <button
                            onClick={() => setParty(prev => prev.slice(0, -1))}
                            className="text-xs text-red-400 hover:underline"
                          >
                            æœ€å¾Œã®å†’é™ºè€…ã‚’è§£é›‡
                          </button>
                        )}
                      </div>
                    )}
                  </>
                )}

                {activeTab === 'dungeon' && (
                  <>
                    <h2 className="text-base mb-2 border-b border-green-800 pb-1">ã€ ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³é¸æŠ ã€‘</h2>
                    {!exploring ? (
                      <>
                        <div className="grid md:grid-cols-2 gap-2 mb-3">
                          {DUNGEONS.map(d => {
                            const avgLv = party.length > 0 ? Math.floor(party.reduce((a, c) => a + c.level, 0) / party.length) : 0;
                            const canEnter = avgLv >= d.minLv;
                            return (
                              <button
                                key={d.id}
                                onClick={() => canEnter && setCurrentDungeon(d.id)}
                                disabled={!canEnter}
                                className={`text-left p-2 text-xs ${currentDungeon === d.id ? 'bg-green-900 retro-border' : 'bg-gray-900'} 
                                  ${canEnter ? 'hover:bg-green-800' : 'opacity-50 cursor-not-allowed'}`}
                              >
                                <div className="flex justify-between">
                                  <span className="font-bold">{d.name}</span>
                                  <span className="text-gray-500">B{d.floors}F</span>
                                </div>
                                <div className="text-gray-500">
                                  æ¨å¥¨Lv.{d.minLv}+ {maxFloors[d.id] ? `(æœ€æ·±:B${maxFloors[d.id]}F)` : ''}
                                </div>
                              </button>
                            );
                          })}
                        </div>
                        <div className="mb-3 p-2 bg-gray-900 text-xs">
                          <p className="mb-1">é›¢è„±æ¡ä»¶: HP {retreatCondition.value}% ä»¥ä¸‹ã§å¸°é‚„</p>
                          <input
                            type="range"
                            min="10"
                            max="50"
                            value={retreatCondition.value}
                            onChange={(e) => setRetreatCondition({ ...retreatCondition, value: parseInt(e.target.value) })}
                            className="w-full"
                          />
                        </div>
                        <button
                          onClick={() => {
                            if (party.length === 0) return alert('å†’é™ºè€…ã‚’ç™»éŒ²ã—ã¦ãã ã•ã„');
                            if (!currentDungeon) return alert('ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„');
                            setExploring(true);
                            setCurrentFloor(1);
                            setLogs([]);
                            const d = DUNGEONS.find(d => d.id === currentDungeon);
                            addLog(`ã€${d.name}ã€‘ã¸å‡ºç™ºï¼`, 'level');
                          }}
                          disabled={party.length === 0 || !currentDungeon}
                          className="w-full retro-border py-2 hover:bg-green-900 disabled:opacity-50"
                        >
                          â–¶ æ¢ç´¢é–‹å§‹
                        </button>
                      </>
                    ) : (
                      <div className="text-center py-8">
                        <p className="text-2xl mb-2 blink gold-text">æ¢ç´¢ä¸­...</p>
                        <p className="text-4xl mb-2">ğŸ° B{currentFloor}F</p>
                        <p className="text-sm text-gray-400 mb-4">
                          {DUNGEONS.find(d => d.id === currentDungeon)?.name}
                        </p>
                        <button
                          onClick={() => {
                            setExploring(false);
                            setCurrentFloor(1);
                            setParty(prev => prev.map(c => ({ ...c, currentHp: c.maxHp, currentMp: c.maxMp })));
                            addLog('ãƒ‘ãƒ¼ãƒ†ã‚£ã¯è¡—ã«å¸°é‚„ã—ãŸ', 'heal');
                          }}
                          className="retro-border px-8 py-2 hover:bg-red-900 text-red-400"
                        >
                          â–  å¸°é‚„
                        </button>
                      </div>
                    )}
                  </>
                )}

                {activeTab === 'quest' && (
                  <>
                    <h2 className="text-base mb-2 border-b border-green-800 pb-1">ã€ ã‚¯ã‚¨ã‚¹ãƒˆ ã€‘</h2>
                    <div className="space-y-2 max-h-80 overflow-y-auto">
                      {QUESTS.map(quest => {
                        const completed = completedQuests.includes(quest.id);
                        return (
                          <div key={quest.id} className={`p-2 text-xs ${completed ? 'bg-green-900 opacity-75' : 'bg-gray-900'}`}>
                            <div className="flex justify-between">
                              <span className="font-bold">{completed ? 'âœ“ ' : ''}{quest.name}</span>
                              <span className="gold-text">{quest.reward.gold}G / {quest.reward.exp}EXP</span>
                            </div>
                            <p className="text-gray-400 mt-1">{quest.desc}</p>
                          </div>
                        );
                      })}
                    </div>
                    <p className="mt-2 text-xs text-gray-500">é”æˆ: {completedQuests.length}/{QUESTS.length}</p>
                  </>
                )}

                {activeTab === 'bestiary' && (
                  <>
                    <h2 className="text-base mb-2 border-b border-green-800 pb-1">ã€ ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼å›³é‘‘ ã€‘</h2>
                    <div className="grid md:grid-cols-2 gap-2 max-h-80 overflow-y-auto">
                      {Object.entries(bestiary).map(([name, data]) => (
                        <div key={name} className="p-2 bg-gray-900 text-xs">
                          <div className="flex justify-between">
                            <span className="font-bold">{data.boss ? 'ğŸ‘‘ ' : ''}{name}</span>
                            <span className="text-gray-500">Ã—{data.encountered}</span>
                          </div>
                          <div className="text-gray-400 mt-1">
                            HP:{data.hp} ATK:{data.atk} EXP:{data.exp}
                          </div>
                        </div>
                      ))}
                    </div>
                    <p className="mt-2 text-xs text-gray-500">ç™ºè¦‹: {Object.keys(bestiary).length}/{MONSTERS.length}ç¨®</p>
                  </>
                )}

                {activeTab === 'shop' && (
                  <>
                    <h2 className="text-base mb-2 border-b border-green-800 pb-1">ã€ ãƒœãƒ«ã‚¿ãƒƒã‚¯å•†åº— ã€‘</h2>
                    <div className="grid md:grid-cols-2 gap-3">
                      {/* å•†å“ */}
                      <div>
                        <h3 className="text-xs text-gray-400 mb-2">è²©å£²ä¸­</h3>
                        <div className="space-y-1 max-h-48 overflow-y-auto">
                          {[...ITEMS.weapons, ...ITEMS.armors, ...ITEMS.accessories].slice(0, 15).map((item, i) => {
                            const canBuy = gold >= item.price;
                            const avgLv = party.length > 0 ? Math.floor(party.reduce((a, c) => a + c.level, 0) / party.length) : 0;
                            const available = avgLv >= item.minLv;
                            return (
                              <div key={i} className={`p-1 text-xs flex justify-between ${available && canBuy ? 'bg-gray-900' : 'bg-gray-900 opacity-50'}`}>
                                <span>{item.name} {item.atk ? `(ATK+${item.atk})` : ''}{item.def ? `(DEF+${item.def})` : ''}</span>
                                <button
                                  onClick={() => {
                                    if (!canBuy || !available) return;
                                    setGold(prev => prev - item.price);
                                    setInventory(prev => [...prev, { ...item, id: Date.now() }]);
                                    addLog(`${item.name}ã‚’è³¼å…¥ã—ãŸ`, 'item');
                                    soundEngine.playGold();
                                  }}
                                  disabled={!canBuy || !available}
                                  className="gold-text hover:underline disabled:opacity-50"
                                >
                                  {item.price}G
                                </button>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                      {/* ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª */}
                      <div>
                        <h3 className="text-xs text-gray-400 mb-2">æ‰€æŒå“ ({inventory.length})</h3>
                        <div className="space-y-1 max-h-48 overflow-y-auto">
                          {inventory.map((item, i) => (
                            <div key={item.id} className="p-1 text-xs bg-gray-900 flex justify-between items-center">
                              <span>{item.name}</span>
                              <div className="flex gap-1">
                                {party.map(char => (
                                  <button
                                    key={char.id}
                                    onClick={() => {
                                      const slot = item.atk && !item.def ? 'weapon' : item.def && !item.atk ? 'armor' : 'accessory';
                                      equipItem(char.id, item, slot);
                                    }}
                                    className="text-blue-400 hover:underline text-[10px]"
                                    title={`${char.name}ã«è£…å‚™`}
                                  >
                                    {char.name.slice(0, 2)}
                                  </button>
                                ))}
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    </div>
                  </>
                )}
              </div>

              {/* æ¢ç´¢ãƒ­ã‚° */}
              <div className="retro-border p-3">
                <h2 className="text-base mb-2 border-b border-green-800 pb-1">ã€ æ¢ç´¢ãƒ­ã‚° ã€‘</h2>
                <div ref={logRef} className="h-80 overflow-y-auto bg-black p-2 text-xs log-scroll">
                  {logs.length === 0 ? (
                    <p className="text-gray-600">ãƒ­ã‚°ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...</p>
                  ) : (
                    logs.map((log, i) => (
                      <p key={i} className={`${log.color} mb-1`}>&gt; {log.message}</p>
                    ))
                  )}
                </div>
              </div>
            </div>

            <div className="text-center mt-3 text-xs text-gray-600">
              <button onClick={() => setScreen('title')} className="hover:text-green-400">
                ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹
              </button>
              <span className="mx-2">|</span>
              <span>v3.0 - BGM/SFX/Quest/Bestiary/Shop</span>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
